<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="UTF-8" />
  <title>Enhanced Cutting Diagram v3.0 - Professional Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --primary-color: #2563eb;
      --secondary-color: #f59e0b;
      --success-color: #10b981;
      --danger-color: #ef4444;
      --warning-color: #f59e0b;
      --info-color: #06b6d4;
      --light-bg: #f8fafc;
      --dark-bg: #1e293b;
      --border-color: #e2e8f0;
      --text-color: #334155;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    * { box-sizing: border-box; }
    
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      margin: 0; 
      padding: 20px; 
      background: var(--light-bg);
      color: var(--text-color);
      transition: all 0.3s ease;
    }

    /* Header Styles */
    #header-row { 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 15px;
    }

    #upload-controls { 
      display: flex; 
      align-items: center; 
      gap: 15px; 
      flex-wrap: wrap;
    }

    .file-input-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }

    .file-input-wrapper input[type=file] {
      position: absolute;
      left: -9999px;
    }

    .file-input-label {
      padding: 10px 16px;
      background: var(--primary-color);
      color: white;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      border: none;
      font-size: 14px;
      font-weight: 500;
    }

    .file-input-label:hover {
      background: #1d4ed8;
      transform: translateY(-1px);
    }

    #processBtn, .action-btn {
      padding: 12px 24px;
      background: var(--success-color);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 14px;
    }

    #processBtn:hover, .action-btn:hover {
      background: #059669;
      transform: translateY(-1px);
      box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .icon-btn {
      background: none;
      border: none;
      font-size: 1.8em;
      cursor: pointer;
      padding: 8px;
      border-radius: 8px;
      transition: all 0.3s ease;
    }

    .icon-btn:hover {
      background: rgba(37, 99, 235, 0.1);
      transform: scale(1.1);
    }

    /* Tabs */
    #tabs-row { 
      display: flex; 
      justify-content: flex-end; 
      margin-bottom: 20px;
    }

    #tabs { 
      display: flex; 
      flex-wrap: wrap;
      gap: 8px;
    }

    .tab { 
      padding: 15px 20px; 
      cursor: pointer; 
      background: white; 
      border-radius: 12px 12px 0 0; 
      border: 2px solid var(--border-color);
      border-bottom: none; 
      transition: all 0.3s ease;
      min-width: 120px;
      text-align: center;
      font-weight: 500;
      position: relative;
      overflow: hidden;
    }

    .tab::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--primary-color);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }

    .tab:hover::before {
      transform: scaleX(1);
    }

    .tab.selected { 
      background: var(--secondary-color); 
      border-color: var(--secondary-color);
      color: #92400e; 
      font-weight: 700;
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3);
    }

    .tab.selected::before {
      transform: scaleX(1);
      background: #92400e;
    }

    /* Main Content Area */
    .main-container {
      background: white;
      border-radius: 12px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    #main-flex-row { 
      display: flex; 
      height: 800px; 
      position: relative;
    }

    #svg-board-wrap { 
      min-width: 300px; 
      width: 65%; 
      transition: width 0.3s ease; 
      position: relative;
    }

    #svg-board-inside {
      padding: 20px;
      height: 100%;
      overflow: hidden;
      position: relative;
    }

    #divider {
      width: 8px; 
      cursor: ew-resize; 
      background: linear-gradient(90deg, var(--border-color) 0%, #cbd5e1 50%, var(--border-color) 100%);
      position: relative;
      transition: all 0.3s ease;
    }

    #divider:hover {
      background: var(--primary-color);
      width: 12px;
    }

    #side-table { 
      min-width: 250px; 
      width: 35%; 
      background: #f8fafc;
      overflow-y: auto; 
      padding: 20px;
      transition: width 0.3s ease;
    }

    /* SVG Styles */
    .svg-container {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      background: #ffffff;
      border: 2px solid var(--border-color);
    }

    #svgMain {
      width: 100%;
      height: 100%;
      cursor: grab;
      user-select: none;
    }

    #svgMain:active {
      cursor: grabbing;
    }

    /* Controls */
    .controls-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: white;
      border-top: 2px solid var(--border-color);
      flex-wrap: wrap;
      gap: 15px;
    }

    .page-btns { 
      display: flex; 
      flex-wrap: wrap; 
      align-items: center;
      gap: 10px;
    }

    .sheet-col { 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      gap: 6px;
    }

    .sheet-btn { 
      min-width: 45px;
      height: 45px;
      font-size: 16px; 
      border-radius: 10px; 
      border: 2px solid var(--primary-color); 
      background: white; 
      color: var(--primary-color); 
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .sheet-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(37, 99, 235, 0.3);
    }

    .sheet-btn.selected { 
      background: var(--secondary-color); 
      border-color: var(--secondary-color);
      color: #92400e;
    }

    .sheet-btn.complete { 
      background: var(--success-color) !important; 
      color: white !important; 
      border-color: var(--success-color);
    }

    .done-btn { 
      font-size: 12px; 
      background: white; 
      border: 2px solid var(--success-color); 
      color: var(--success-color); 
      border-radius: 6px; 
      padding: 4px 8px; 
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 500;
    }

    .done-btn:hover {
      background: var(--success-color);
      color: white;
    }

    .done-btn.done { 
      background: var(--success-color); 
      color: white;
    }

    .reset-btn { 
      font-size: 14px; 
      background: white; 
      border: 2px solid var(--danger-color); 
      color: var(--danger-color); 
      border-radius: 8px; 
      padding: 10px 20px; 
      cursor: pointer; 
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .reset-btn:hover {
      background: var(--danger-color);
      color: white;
      transform: translateY(-1px);
    }

    .zoom-controls { 
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .zoom-btn { 
      font-size: 14px;
      padding: 8px 12px;
      background: white;
      border: 2px solid var(--info-color);
      color: var(--info-color);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 500;
    }

    .zoom-btn:hover {
      background: var(--info-color);
      color: white;
      transform: scale(1.05);
    }

    /* Side Panel */
    .side-header {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 15px;
      color: var(--primary-color);
      border-bottom: 2px solid var(--border-color);
      padding-bottom: 8px;
    }

    .side-part-row { 
      display: flex; 
      align-items: center; 
      justify-content: space-between; 
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 8px;
      background: white;
      transition: all 0.3s ease;
    }

    .side-part-row:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow);
      border-color: var(--primary-color);
    }

    .side-part-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex-grow: 1;
    }

    .side-part-name { 
      font-size: 14px; 
      font-weight: 600;
      color: var(--text-color);
    }

    .side-part-dim { 
      color: var(--info-color); 
      font-size: 12px;
      font-weight: 500;
    }

    .side-print-btn { 
      font-size: 12px;
      border-radius: 6px; 
      border: 2px solid var(--primary-color); 
      background: white; 
      color: var(--primary-color); 
      padding: 6px 12px; 
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
    }

    .side-print-btn:hover {
      background: var(--primary-color);
      color: white;
      transform: scale(1.05);
    }

    /* Popups */
    .popup { 
      display: none; 
      position: fixed; 
      top: 50%; 
      left: 50%; 
      background: white; 
      border-radius: 16px; 
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      min-width: 400px;
      max-width: 90vw;
      max-height: 90vh;
      transform: translate(-50%, -50%); 
      z-index: 2000; 
      padding: 30px;
      overflow-y: auto;
    }

    .popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid var(--border-color);
    }

    .popup h3 {
      margin: 0;
      color: var(--primary-color);
      font-size: 24px;
      font-weight: 700;
    }

    .close-btn { 
      font-size: 24px;
      color: var(--text-color);
      cursor: pointer; 
      font-weight: 700;
      width: 35px;
      height: 35px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.3s ease;
    }

    .close-btn:hover {
      background: var(--danger-color);
      color: white;
      transform: rotate(90deg);
    }

    .overlay { 
      display: none; 
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 1999;
    }

    /* Settings */
    .settings-group {
      margin-bottom: 20px;
      padding: 15px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .settings-group label {
      font-weight: 600;
      color: var(--text-color);
      display: block;
      margin-bottom: 8px;
    }

    .settings-group input, .settings-group select {
      padding: 8px 12px;
      border: 2px solid var(--border-color);
      border-radius: 6px;
      font-size: 14px;
      transition: all 0.3s ease;
      width: 100%;
      max-width: 200px;
    }

    .settings-group input:focus, .settings-group select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    .settings-row {
      display: flex;
      align-items: center;
      gap: 15px;
      flex-wrap: wrap;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: var(--shadow);
      margin: 15px 0;
    }

    th, td { 
      border: 1px solid var(--border-color);
      padding: 12px;
      text-align: left;
    }

    th { 
      background: var(--primary-color);
      color: white;
      font-weight: 600;
    }

    tr:nth-child(even) {
      background: #f8fafc;
    }

    tr:hover {
      background: #e0f2fe;
    }

    /* Print Styles */
    .print-all-btn { 
      padding: 12px 24px;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .print-all-btn:hover { 
      background: #1d4ed8;
      transform: translateY(-1px);
      box-shadow: 0 8px 25px rgba(37, 99, 235, 0.3);
    }

    /* Error Messages */
    .error, .warn {
      color: var(--danger-color);
      font-weight: 600;
      padding: 15px;
      background: #fef2f2;
      border: 2px solid #fecaca;
      border-radius: 8px;
      margin: 15px 0;
    }

    .success {
      color: var(--success-color);
      font-weight: 600;
      padding: 15px;
      background: #f0fdf4;
      border: 2px solid #bbf7d0;
      border-radius: 8px;
      margin: 15px 0;
    }

    .info {
      color: var(--info-color);
      font-weight: 500;
      padding: 15px;
      background: #f0f9ff;
      border: 2px solid #bae6fd;
      border-radius: 8px;
      margin: 15px 0;
    }

    /* Dark Mode */
    body.darkmode {
      background: var(--dark-bg);
      color: #e2e8f0;
      --light-bg: #1e293b;
      --border-color: #475569;
      --text-color: #e2e8f0;
    }

    body.darkmode .main-container,
    body.darkmode #header-row,
    body.darkmode .tab,
    body.darkmode .popup,
    body.darkmode .side-part-row,
    body.darkmode .settings-group,
    body.darkmode table,
    body.darkmode .svg-container {
      background: #334155;
      border-color: #475569;
      color: #e2e8f0;
    }

    body.darkmode th {
      background: #1e40af;
    }

    body.darkmode tr:nth-child(even) {
      background: #475569;
    }

    body.darkmode #side-table {
      background: #334155;
    }

    /* Responsive Design */
    @media (max-width: 1200px) {
      #main-flex-row {
        height: auto;
        flex-direction: column;
      }

      #svg-board-wrap, #side-table {
        width: 100% !important;
      }

      #divider {
        display: none;
      }

      .popup {
        min-width: 320px;
        margin: 20px;
      }
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      #header-row {
        flex-direction: column;
        text-align: center;
      }

      #upload-controls {
        justify-content: center;
      }

      .tab {
        min-width: 100px;
        padding: 12px 15px;
        font-size: 14px;
      }

      .page-btns {
        justify-content: center;
      }
    }

    /* Keyboard Shortcuts Help */
    .shortcuts-help {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .shortcuts-help.show {
      opacity: 1;
    }

    /* Loading Animation */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(37, 99, 235, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Progress Indicators */
    .progress-bar {
      width: 100%;
      height: 8px;
      background: var(--border-color);
      border-radius: 4px;
      overflow: hidden;
      margin: 10px 0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--success-color), var(--info-color));
      width: 0%;
      transition: width 0.5s ease;
      border-radius: 4px;
    }

    /* Status Indicators */
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-indicator.printed {
      background: var(--success-color);
      box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
    }

    .status-indicator.pending {
      background: var(--warning-color);
      box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2);
    }

    /* Drag and Drop Styles */
    .drag-over {
      border: 3px dashed var(--primary-color) !important;
      background: rgba(37, 99, 235, 0.05) !important;
    }

    .dragging {
      opacity: 0.7;
      transform: scale(0.98);
    }

    @media print {
      #header-row, #tabs-row, #error, .controls-row, .zoom-controls, #popup, #overlay, #printLabel, .shortcuts-help { 
        display: none !important; 
      }
      
      .print-page { 
        page-break-after: always; 
        width: 100vw !important; 
        min-height: 1100px !important; 
      }
      
      .print-svg { 
        display: block !important; 
        margin: 0 auto; 
      }

      body {
        background: white !important;
        color: black !important;
      }
    }
  </style>
</head>
<body>
  
  <!-- Zebra Browser Print SDK -->
  <script src="https://localhost:9101/BrowserPrint-3.0.216.min.js"></script>
  
  <!-- jsPDF for PDF Export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  
  <script>
    // Enhanced Zebra Printer Integration
    let zebraPrinter = null;
    let printerStatus = 'disconnected';
    let printerCapabilities = {};

    function discoverZebraPrinter(callback) {
      if (window.BrowserPrint && BrowserPrint.getDefaultDevice) {
        // First try to get default printer
        BrowserPrint.getDefaultDevice('printer', function(printer) {
          zebraPrinter = printer;
          printerStatus = 'connected';
          
          // Get printer capabilities
          if (printer && printer.getStatus) {
            printer.getStatus(function(status) {
              printerCapabilities = status;
              console.log('Zebra Printer Connected:', status);
            });
          }
          
          callback(true);
        }, function(error) {
          console.log('Default printer not found, searching for Zebra devices...');
          
          // If no default, search for Zebra printers specifically
          BrowserPrint.getLocalDevices(function(devices) {
            let zebraDevice = devices.find(device => 
              device.name && (
                device.name.toLowerCase().includes('zebra') || 
                device.name.toLowerCase().includes('zt230') ||
                device.uid.toLowerCase().includes('zebra')
              )
            );
            
            if (zebraDevice) {
              zebraPrinter = zebraDevice;
              printerStatus = 'connected';
              callback(true);
            } else {
              zebraPrinter = null;
              printerStatus = 'not_found';
              callback(false);
            }
          }, function() {
            zebraPrinter = null;
            printerStatus = 'error';
            callback(false);
          });
        });
      } else {
        zebraPrinter = null;
        printerStatus = 'browser_print_not_loaded';
        callback(false);
      }
    }

// Enhanced ZPL Generation for ZT230
    function generateZT230ZPL(componentData, settings = {}) {
      const {
        name = '',
        length = 0,
        width = 0,
        material = '',
        edging = {},
        notes1 = '',
        notes2 = '',
        fontSize = settings.labelFontSize || 18,
        bold = settings.labelBold || false,
        margin = settings.labelMargin || 6
      } = componentData;

      // ZT230 specific settings (203 DPI, 4" wide)
      const dpi = 203;
      const labelWidth = Math.floor(4 * dpi); // 812 dots for 4" width
      const labelHeight = Math.floor(2 * dpi); // 406 dots for 2" height
      
      // Convert mm to dots (203 DPI = ~8 dots per mm)
      const marginDots = Math.floor(margin * 8);
      
      // Font scaling for ZT230
      const fontHeight = Math.max(20, Math.min(60, fontSize * 2));
      const fontWidth = Math.floor(fontHeight * 0.8);

      let zpl = `^XA\n`;
      
      // Set label dimensions
      zpl += `^PW${labelWidth}\n`;
      zpl += `^LL${labelHeight}\n`;
      
      // Border
      zpl += `^FO${marginDots},${marginDots}^GB${labelWidth - (marginDots * 2)},${labelHeight - (marginDots * 2)},3^FS\n`;
      
      // Component name (left aligned)
      zpl += `^FO${marginDots + 20},${marginDots + 20}^A0${bold ? 'B' : 'N'},${fontHeight},${fontWidth}^FB${labelWidth - (marginDots * 2) - 220},2,0,L^FD${name}^FS\n`;
      
      // Dimensions
      zpl += `^FO${marginDots + 20},${marginDots + 100}^A0N,30,24^FD${length} x ${width} mm^FS\n`;
      
      // Material
      if (material) {
        zpl += `^FO${marginDots + 20},${marginDots + 140}^A0N,25,20^FDMaterial: ${material}^FS\n`;
      }
      
      // Edging information (L1/L2 on one row, W1/W2 on another)
      let yPos = marginDots + 180;
      if (edging.el1 || edging.el2 || edging.ew1 || edging.ew2) {
        zpl += `^FO${marginDots + 20},${yPos}^A0N,20,16^FDEdging:^FS\n`;
        yPos += 25;
        
        // L1 and L2 on same row with consistent spacing
        if (edging.el1 || edging.el2) {
          let lText = '';
          lText += edging.el1 ? `L1: ${edging.el1}` : 'L1: None';
          lText += '          '; // Consistent spacing
          lText += edging.el2 ? `L2: ${edging.el2}` : 'L2: None';
          zpl += `^FO${marginDots + 20},${yPos}^A0N,18,14^FD${lText}^FS\n`;
          yPos += 25;
        }
        
        // W1 and W2 on same row with consistent spacing
        if (edging.ew1 || edging.ew2) {
          let wText = '';
          wText += edging.ew1 ? `W1: ${edging.ew1}` : 'W1: None';
          wText += '          '; // Consistent spacing
          wText += edging.ew2 ? `W2: ${edging.ew2}` : 'W2: None';
          zpl += `^FO${marginDots + 20},${yPos}^A0N,18,14^FD${wText}^FS\n`;
          yPos += 25;
        }
      }
      
      // Notes (positioned below edging, followed by timestamp)
      if (notes1) {
        zpl += `^FO${marginDots + 20},${yPos}^A0N,16,12^FDNote 1: ${notes1}^FS\n`;
        yPos += 20;
      }
      if (notes2) {
        zpl += `^FO${marginDots + 20},${yPos}^A0N,16,12^FDNote 2: ${notes2}^FS\n`;
        yPos += 20;
      }
      
      // Timestamp (below notes)
      zpl += `^FO${marginDots + 20},${yPos}^A0N,14,10^FDPrinted: $(DT)^FS\n`;
      
      // Edge diagram (bigger - 20% increase) - positioned on right
      const diagramX = labelWidth - 240;
      const diagramY = marginDots + 20;
      
      // Rectangle (bigger)
      zpl += `^FO${diagramX},${diagramY}^GB120,78,3^FS\n`;
      
      // Edge lines (black dashed lines - simulate with dotted pattern)
      if (edging.el1) {
        // Top edge - simulate dashed line with multiple small rectangles
        for (let i = 0; i < 120; i += 10) {
          if (i % 20 < 10) zpl += `^FO${diagramX + i},${diagramY - 5}^GB8,6,6^FS\n`;
        }
      }
      if (edging.el2) {
        // Bottom edge
        for (let i = 0; i < 120; i += 10) {
          if (i % 20 < 10) zpl += `^FO${diagramX + i},${diagramY + 78}^GB8,6,6^FS\n`;
        }
      }
      if (edging.ew1) {
        // Left edge
        for (let i = 0; i < 78; i += 10) {
          if (i % 20 < 10) zpl += `^FO${diagramX - 5},${diagramY + i}^GB6,8,6^FS\n`;
        }
      }
      if (edging.ew2) {
        // Right edge
        for (let i = 0; i < 78; i += 10) {
          if (i % 20 < 10) zpl += `^FO${diagramX + 120},${diagramY + i}^GB6,8,6^FS\n`;
        }
      }
      
      // Labels for edges
      if (edging.el1) zpl += `^FO${diagramX + 55},${diagramY - 20}^A0N,16,12^FDL1^FS\n`;
      if (edging.el2) zpl += `^FO${diagramX + 55},${diagramY + 95}^A0N,16,12^FDL2^FS\n`;
      if (edging.ew1) zpl += `^FO${diagramX - 25},${diagramY + 35}^A0N,16,12^FDW1^FS\n`;
      if (edging.ew2) zpl += `^FO${diagramX + 130},${diagramY + 35}^A0N,16,12^FDW2^FS\n`;
      
      zpl += `^XZ\n`;
      
      return zpl;
    }
    // Test print function for ZT230
    function testZebraPrint() {
      if (!zebraPrinter) {
        alert('Zebra printer not connected. Please check connection.');
        return;
      }

      const testZPL = `
^XA
^PW812
^LL406
^FO50,50^GB712,306,3^FS
^FO70,70^A0N,40,32^FB652,2,0,C^FDTEST PRINT^FS
^FO70,130^A0N,30,24^FDZEBRA ZT230 CONNECTED^FS
^FO70,170^A0N,25,20^FDDate: $(DT)^FS
^FO70,200^A0N,25,20^FDTime: $(TM)^FS
^FO70,240^A0N,20,16^FDCutting Diagram v3.0^FS
^FO600,280^BQN,2,3^FDQA,Test Print Successful^FS
^XZ
      `;

      zebraPrinter.send(testZPL, function(success) {
        showNotification('Test print sent successfully!', 'success');
      }, function(error) {
        showNotification('Print error: ' + error, 'error');
        console.error('Zebra print error:', error);
      });
    }
  </script>

  <!-- Main Interface -->
  <div id="header-row">
    <div id="upload-controls">
      <div class="file-input-wrapper">
        <input type="file" id="cuttingCsv" accept=".csv" />
        <label for="cuttingCsv" class="file-input-label">📋 Upload Cutting List</label>
      </div>
      
      <div class="file-input-wrapper">
        <input type="file" id="masterCsv" accept=".csv" />
        <label for="masterCsv" class="file-input-label">📏 Upload Board Master</label>
      </div>
      
      <button id="processBtn">🚀 Process CSVs</button>
    </div>
    
    <div class="header-controls">
      <button id="printAllBtn" class="print-all-btn" style="display:none;">🖨️ Print All</button>
      <button id="exportPdfBtn" class="action-btn" style="display:none; background: var(--danger-color);">📄 Export PDF</button>
      <button id="saveProjectBtn" class="action-btn" style="display:none; background: var(--info-color);">💾 Save Project</button>
      <button id="testPrintBtn" class="icon-btn" title="Test Zebra Printer" style="display:none;">🖨️</button>
      <button id="settingsBtn" class="icon-btn" title="Settings">⚙️</button>
      <button id="helpBtn" class="icon-btn" title="Help & Shortcuts">❓</button>
      <button id="darkModeBtn" class="icon-btn" title="Toggle Dark Mode">🌙</button>
    </div>
  </div>

  <!-- Progress Bar -->
  <div id="progressContainer" style="display:none;">
    <div class="progress-bar">
      <div id="progressFill" class="progress-fill"></div>
    </div>
    <div id="progressText" class="info" style="text-align: center; margin: 10px 0;"></div>
  </div>

  <!-- Tabs -->
  <div id="tabs-row">
    <div id="tabs"></div>
  </div>

  <!-- Error/Status Messages -->
  <div id="error" class="error" style="display:none;"></div>
  <div id="success" class="success" style="display:none;"></div>
  <div id="info" class="info" style="display:none;"></div>

  <!-- Main Content -->
  <div class="main-container">
    <div id="tab-content"></div>
  </div>

  <!-- Notifications -->
  <div id="notifications" style="position: fixed; top: 20px; right: 20px; z-index: 3000;"></div>

  <!-- Keyboard Shortcuts Help -->
  <div id="shortcutsHelp" class="shortcuts-help">
    <strong>Keyboard Shortcuts:</strong><br>
    Ctrl+P: Print All | Ctrl+S: Save | Ctrl+E: Export PDF<br>
    Space: Next Sheet | Shift+Space: Previous Sheet<br>
    +/-: Zoom In/Out | R: Reset View | D: Dark Mode
  </div>

  <!-- Popups -->
  <div id="popup" class="popup"></div>
  <div id="overlay" class="overlay"></div>

  <!-- Settings Popup -->
  <div id="settingsPopup" class="popup" style="display:none; min-width: 600px;">
    <div class="popup-header">
      <h3>⚙️ Settings</h3>
      <span class="close-btn" id="settingsCloseBtn">&times;</span>
    </div>
    
    <div class="settings-group">
      <label>🔐 Security PIN:</label>
      <div class="settings-row">
        <input type="password" id="pinInput" maxlength="4" pattern="[0-9]*" inputmode="numeric" placeholder="Enter 4 digits">
        <button id="savePinBtn" class="action-btn">Set PIN</button>
        <span id="pinStatus"></span>
      </div>
    </div>

    <div class="settings-group">
      <label>🏷️ Label Settings:</label>
      <div class="settings-row">
        <div>
          <label>Font Size:</label>
          <input type="number" id="labelFontSize" min="8" max="40" value="18"> px
        </div>
        <div>
          <label>Margin:</label>
          <input type="number" id="labelMargin" min="0" max="15" value="6"> mm
        </div>
        <div>
          <input type="checkbox" id="labelBold">
          <label for="labelBold">Bold Text</label>
        </div>
      </div>
    </div>

    <div class="settings-group">
      <label>📐 Cutting Parameters:</label>
      <div class="settings-row">
        <div>
          <label>Kerf Width:</label>
          <input type="number" id="kerfWidth" min="0" max="10" value="4" step="0.5"> mm
        </div>
        <div>
          <label>Min Offcut Length:</label>
          <input type="number" id="minOffcutL" value="300" min="0" max="10000"> mm
        </div>
        <div>
          <label>Min Offcut Width:</label>
          <input type="number" id="minOffcutW" value="200" min="0" max="10000"> mm
        </div>
      </div>
    </div>

    <div class="settings-group">
      <label>🎯 Optimization Settings:</label>
      <div class="settings-row">
        <div>
          <label>Grain Direction Priority:</label>
          <select id="grainPriority">
            <option value="none">No Preference</option>
            <option value="length">Prefer Length Direction</option>
            <option value="width">Prefer Width Direction</option>
            <option value="material">Follow Material Setting</option>
          </select>
        </div>
        <div>
          <label>Nesting Algorithm:</label>
          <select id="nestingAlgorithm">
            <option value="maxrect">Max Rectangles (Default)</option>
            <option value="bottom_left">Bottom-Left Fill</option>
            <option value="best_fit">Best Fit Decreasing</option>
          </select>
        </div>
      </div>
    </div>

    <div class="settings-group">
      <label>🖨️ Printer Settings:</label>
      <div class="settings-row">
        <div>
          <label>Printer Type:</label>
          <select id="printerType">
            <option value="zebra_zt230">Zebra ZT230</option>
            <option value="zebra_gk420d">Zebra GK420D</option>
            <option value="zebra_zd410">Zebra ZD410</option>
            <option value="generic">Generic Zebra</option>
          </select>
        </div>
        <div>
          <label>Label Size:</label>
          <select id="labelSize">
            <option value="4x2">4" x 2"</option>
            <option value="4x3">4" x 3"</option>
            <option value="4x6">4" x 6"</option>
          </select>
        </div>
        <div>
          <button id="testPrintSettingsBtn" class="action-btn">Test Print</button>
        </div>
      </div>
      <div id="printerStatus" class="info" style="margin-top: 10px;"></div>
    </div>
  </div>

  <!-- Help Popup -->
  <div id="helpPopup" class="popup" style="display:none; min-width: 700px;">
    <div class="popup-header">
      <h3>❓ Help & Instructions</h3>
      <span class="close-btn" id="helpCloseBtn">&times;</span>
    </div>
    
    <div style="max-height: 600px; overflow-y: auto;">
      <h4>🚀 Getting Started</h4>
      <ol>
        <li><strong>Upload Files:</strong> Select your Cutting List CSV and Board Master CSV files</li>
        <li><strong>Process:</strong> Click "Process CSVs" to generate cutting diagrams</li>
        <li><strong>Review:</strong> Navigate between material tabs and sheet pages</li>
        <li><strong>Print:</strong> Click individual parts to print labels, or "Print All" for complete diagrams</li>
      </ol>

      <h4>📋 CSV File Requirements</h4>
      <h5>Cutting List CSV Headers:</h5>
      <ul>
        <li><code>Name</code> - Component name</li>
        <li><code>Length</code> - Length in mm</li>
        <li><code>Width</code> - Width in mm</li>
        <li><code>Quantity</code> - Number of pieces</li>
        <li><code>Material</code> - Material type</li>
        <li><code>Can Rotate (0 = No / 1 = Yes / 2 = Same As Material)</code></li>
        <li><code>Edging Length 1/2</code>, <code>Edging Width 1/2</code> - Edge banding info</li>
      </ul>

      <h5>Board Master CSV Headers:</h5>
      <ul>
        <li><code>Material</code> - Material type (must match Cutting List)</li>
        <li><code>board length  </code> - Sheet length in mm</li>
        <li><code>board width  </code> - Sheet width in mm</li>
      </ul>

      <h4>⌨️ Keyboard Shortcuts</h4>
      <table>
        <tr><th>Shortcut</th><th>Action</th></tr>
        <tr><td>Ctrl+P</td><td>Print all sheets</td></tr>
        <tr><td>Ctrl+S</td><td>Save project</td></tr>
        <tr><td>Ctrl+E</td><td>Export PDF</td></tr>
        <tr><td>Space</td><td>Next sheet</td></tr>
        <tr><td>Shift+Space</td><td>Previous sheet</td></tr>
        <tr><td>+/-</td><td>Zoom in/out</td></tr>
        <tr><td>R</td><td>Reset view</td></tr>
        <tr><td>D</td><td>Toggle dark mode</td></tr>
        <tr><td>Esc</td><td>Close popup/cancel</td></tr>
      </table>

      <h4>🖨️ Zebra Printer Setup</h4>
      <ol>
        <li>Install Zebra Browser Print from <a href="https://www.zebra.com/us/en/software/printer-software/browser-print.html" target="_blank">zebra.com</a></li>
        <li>Connect your ZT230 printer via USB or network</li>
        <li>Ensure Browser Print service is running (default port 9101)</li>
        <li>Click "Test Print" to verify connection</li>
      </ol>

      <h4>🎯 Optimization Tips</h4>
      <ul>
        <li><strong>Material Grouping:</strong> Parts are automatically grouped by material type</li>
        <li><strong>Rotation:</strong> Enable rotation for better material utilization</li>
        <li><strong>Grain Direction:</strong> Set grain preferences in settings</li>
        <li><strong>Kerf Width:</strong> Adjust cutting blade width for accurate spacing</li>
        <li><strong>Minimum Offcuts:</strong> Set minimum sizes to track usable waste pieces</li>
      </ul>
    </div>
  </div>

  <!-- Project Save/Load Popup -->
  <div id="projectPopup" class="popup" style="display:none;">
    <div class="popup-header">
      <h3>💾 Project Management</h3>
      <span class="close-btn" id="projectCloseBtn">&times;</span>
    </div>
    
    <div class="settings-group">
      <label>Save Current Project:</label>
      <div class="settings-row">
        <input type="text" id="projectName" placeholder="Enter project name" style="flex-grow: 1;">
        <button id="saveProjectConfirmBtn" class="action-btn">Save</button>
      </div>
    </div>

    <div class="settings-group">
      <label>Load Saved Project:</label>
      <select id="savedProjects" style="width: 100%; margin-bottom: 10px;">
        <option value="">Select a saved project...</option>
      </select>
      <div class="settings-row">
        <button id="loadProjectBtn" class="action-btn" style="background: var(--info-color);">Load</button>
        <button id="deleteProjectBtn" class="action-btn" style="background: var(--danger-color);">Delete</button>
      </div>
    </div>
  </div>

  <!-- Hidden elements for processing -->
  <div id="printPagesHolder" style="display:none;"></div>

  <script>
    // Global Variables
    let printedParts = {};
    let completedPages = {};
    let currentBoards = [];
    let currentGroups = {};
  let currentSheets = {};
  let currentSheetPage = {};
    let originalParts = [];
  let partPlacementMap = {};
    let boardSizes = {};
    let masterBoardDB = {};
    
    // View state
    let zoomLevel = 1;
    let panX = 0;
    let panY = 0;
    let svgW = 1200;
    let svgH = 750;
    let PAD = 60;
    
    // Settings
    let appSettings = {
      labelFontSize: 18,
      labelBold: false,
      labelMargin: 6,
      kerfWidth: 4,
      minOffcutL: 300,
      minOffcutW: 200,
      grainPriority: 'none',
      nestingAlgorithm: 'maxrect',
      printerType: 'zebra_zt230',
      labelSize: '4x2'
    };

    // Load settings from localStorage
    function loadSettings() {
      const saved = localStorage.getItem('cuttingDiagramSettings');
      if (saved) {
        appSettings = { ...appSettings, ...JSON.parse(saved) };
      }
      updateSettingsUI();
    }

    function saveSettings() {
      localStorage.setItem('cuttingDiagramSettings', JSON.stringify(appSettings));
    }

    function updateSettingsUI() {
      document.getElementById('labelFontSize').value = appSettings.labelFontSize;
      document.getElementById('labelBold').checked = appSettings.labelBold;
      document.getElementById('labelMargin').value = appSettings.labelMargin;
      document.getElementById('kerfWidth').value = appSettings.kerfWidth;
      document.getElementById('minOffcutL').value = appSettings.minOffcutL;
      document.getElementById('minOffcutW').value = appSettings.minOffcutW;
      document.getElementById('grainPriority').value = appSettings.grainPriority;
      document.getElementById('nestingAlgorithm').value = appSettings.nestingAlgorithm;
      document.getElementById('printerType').value = appSettings.printerType;
      document.getElementById('labelSize').value = appSettings.labelSize;
    }

    // Notification System
    function showNotification(message, type = 'info', duration = 5000) {
      const container = document.getElementById('notifications');
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.style.cssText = `
        background: ${type === 'error' ? 'var(--danger-color)' : 
                   type === 'success' ? 'var(--success-color)' : 
                   type === 'warning' ? 'var(--warning-color)' : 'var(--info-color)'};
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        margin-bottom: 10px;
        box-shadow: var(--shadow);
        animation: slideIn 0.3s ease;
        cursor: pointer;
        min-width: 300px;
        position: relative;
        overflow: hidden;
      `;
      notification.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span>${message}</span>
          <span style="font-size: 18px; margin-left: 15px;">&times;</span>
        </div>
      `;
      
      container.appendChild(notification);
      
      // Auto remove
      setTimeout(() => {
        if (notification.parentNode) {
          notification.style.animation = 'slideOut 0.3s ease';
          setTimeout(() => notification.remove(), 300);
        }
      }, duration);
      
      // Click to remove
      notification.onclick = () => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => notification.remove(), 300);
      };
    }

    // Add animation styles
    const animationStyles = document.createElement('style');
    animationStyles.textContent = `
      @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
      }
    `;
    document.head.appendChild(animationStyles);

    // Enhanced CSV Parsing with Progress
    function parseCSV(csvString) {
      showProgress(10, 'Parsing CSV data...');
      csvString = csvString.replace(/^\uFEFF/, "");
      const lines = [];
      let field = "", row = [], inQuotes = false;
      
      for (let i = 0; i < csvString.length; i++) {
        let char = csvString[i], next = csvString[i+1];
        if (char === '"') {
          if (inQuotes && next === '"') { field += '"'; i++; }
          else { inQuotes = !inQuotes; }
        } else if ((char === ';' || char === ',') && !inQuotes) {
          row.push(field); field = "";
        } else if ((char === "\n" || char === "\r") && !inQuotes) {
          if (char === "\r" && next === "\n") i++;
          row.push(field); lines.push(row); field = ""; row = [];
        } else { field += char; }
        
        // Update progress
        if (i % 1000 === 0) {
          showProgress(10 + (i / csvString.length) * 20, 'Parsing CSV data...');
        }
      }
      
      if (field !== "" || row.length > 0) { row.push(field); lines.push(row);}
      return lines.filter(r => r.some(f => f.trim() !== ""));
    }

    function getHeaders(rows) { return rows[0].map(h=>h.trim()); }

    function buildObjects(rows, headers) {
      let out = [];
      for(let i=1;i<rows.length;i++) {
        let row = rows[i];
        if (row.every(cell => !cell.trim())) continue;
        let obj = {};
        for (let j=0;j<headers.length;j++) obj[headers[j]] = (row[j]||"").trim();
        out.push(obj);
        
        // Update progress
        if (i % 100 === 0) {
          showProgress(30 + (i / rows.length) * 20, `Processing row ${i} of ${rows.length}...`);
        }
      }
      return out;
    }

    function escapeHtml(str) {
      return (str||"").replace(/[&<>"']/g, s =>
        ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s])
      );
    }

    function groupByBoard(objs) {
      let groups = {};
      objs.forEach((o,i)=>{
        let mat = o["Material"];
        let key = mat;
        if(!groups[key]) groups[key] = [];
        groups[key].push({...o, __csvIndex: i});
      });
      return groups;
    }

    function expandQuantities(objs) {
      let out = [];
      objs.forEach((o,i)=>{
        let qty = parseInt(o["Quantity"]) || 1;
        for(let k=0;k<qty;k++) out.push({...o, __csvIndex: i, __instance:k});
      });
      return out;
    }

    // Enhanced Nesting Algorithm with Multiple Strategies
    function nestComponentsOnBoards(components, kerf = 4, BL = 2400, BW = 1200, algorithm = 'maxrect') {
      if (!components.length || !BL || !BW) return [];
      
      showProgress(60, 'Optimizing component placement...');
      
      switch (algorithm) {
        case 'bottom_left':
          return nestBottomLeft(components, kerf, BL, BW);
        case 'best_fit':
          return nestBestFit(components, kerf, BL, BW);
        default:
          return nestMaximalRectangles(components, kerf, BL, BW);
      }
    }

    function nestMaximalRectangles(components, kerf, BL, BW) {
      let comps = components.slice();
      
      // Enhanced sorting with grain direction consideration
      comps.sort((a, b) => {
        const aArea = (parseFloat(a["Length"]) || 0) * (parseFloat(a["Width"]) || 0);
        const bArea = (parseFloat(b["Length"]) || 0) * (parseFloat(b["Width"]) || 0);
        
        // Primary sort by area (largest first)
        if (Math.abs(aArea - bArea) > 100) {
          return bArea - aArea;
        }
        
        // Secondary sort by longest dimension (grain direction optimization)
        const aMax = Math.max(parseFloat(a["Length"]) || 0, parseFloat(a["Width"]) || 0);
        const bMax = Math.max(parseFloat(b["Length"]) || 0, parseFloat(b["Width"]) || 0);
        return bMax - aMax;
      });
      
      let sheets = [];
      
      function findFit(freeRects, l, w, allowRotate) {
        let bestFit = null;
        let bestScore = Infinity;
        
        for (let r of freeRects) {
          // Try normal orientation
          if (l <= r.w && w <= r.h) {
            let wasteArea = (r.w * r.h) - (l * w);
            let score = wasteArea + (r.w - l) + (r.h - w); // Favor tight fits
            if (score < bestScore) {
              bestScore = score;
              bestFit = { x: r.x, y: r.y, rot: false, rect: r, score: score };
            }
          }
          
          // Try rotated orientation
          if (allowRotate && w <= r.w && l <= r.h) {
            let wasteArea = (r.w * r.h) - (w * l);
            let score = wasteArea + (r.w - w) + (r.h - l);
            if (score < bestScore) {
              bestScore = score;
              bestFit = { x: r.x, y: r.y, rot: true, rect: r, score: score };
            }
          }
        }
        
        return bestFit;
      }
      
      while (comps.length) {
        let placed = [];
        let freeRects = [{ x: 0, y: 0, w: BL, h: BW }];
        let left = [];
        
        for (let idx = 0; idx < comps.length; idx++) {
          let c = comps[idx];
          let l = parseFloat(c["Length"]) || 0;
          let w = parseFloat(c["Width"]) || 0;
          
          // Enhanced rotation logic
          let canRotate = true;
          let rotateValue = String(c["Can Rotate (0 = No / 1 = Yes / 2 = Same As Material)"]).trim();
          if (rotateValue === "0") {
            canRotate = false;
          } else if (rotateValue === "2") {
            // Check material-specific rotation rules
            canRotate = true; // Default to true, could be enhanced with material database
          }
          
          // Apply grain direction preferences
          if (appSettings.grainPriority === 'length' && canRotate) {
            // Prefer length in grain direction (longer dimension should be length)
            if (w > l) {
              [l, w] = [w, l]; // Swap dimensions
            }
          } else if (appSettings.grainPriority === 'width' && canRotate) {
            // Prefer width in grain direction
            if (l > w) {
              [l, w] = [w, l]; // Swap dimensions
            }
          }
          
          let fit = findFit(freeRects, l, w, canRotate);
          if (!fit) { 
            left.push(c); 
            continue; 
          }
          
          let px = fit.x, py = fit.y, rotated = fit.rot;
          let plen = rotated ? w : l, pwid = rotated ? l : w;
          
          placed.push({
            x: px, y: py, l: plen, w: pwid, 
            comp: c, idx: c.__csvIndex, 
            instance: c.__instance || 0,
            rotated: rotated,
            wasteScore: fit.score
          });
          
          let rect = fit.rect;
          let newRects = [];
          
          // Create new free rectangles more efficiently
          if (px + plen + kerf < rect.x + rect.w) {
            newRects.push({
              x: px + plen + kerf,
              y: py,
              w: rect.x + rect.w - (px + plen + kerf),
              h: pwid
            });
          }
          
          if (py + pwid + kerf < rect.y + rect.h) {
            newRects.push({
              x: px,
              y: py + pwid + kerf,
              w: plen,
              h: rect.y + rect.h - (py + pwid + kerf)
            });
          }
          
          // Add remaining area as a single rectangle if significant
          let remainingW = rect.x + rect.w - (px + plen + kerf);
          let remainingH = rect.y + rect.h - (py + pwid + kerf);
          if (remainingW > 50 && remainingH > 50) {
            newRects.push({
              x: px + plen + kerf,
              y: py + pwid + kerf,
              w: remainingW,
              h: remainingH
            });
          }
          
          freeRects = freeRects.filter(r => r !== rect);
          freeRects.push(...newRects);
          
          // Remove overlapping rectangles
          freeRects = freeRects.filter((r1, i) => {
            return !freeRects.some((r2, j) => {
              if (i >= j) return false;
              return (r1.x >= r2.x && r1.y >= r2.y && 
                      r1.x + r1.w <= r2.x + r2.w && 
                      r1.y + r1.h <= r2.y + r2.h);
            });
          });
        }
        
        sheets.push(placed);
        if (left.length === comps.length) break; // No progress made
        comps = left;
        
        showProgress(60 + (sheets.length * 5), `Generated ${sheets.length} sheets...`);
      }
      
      return sheets;
    }

    // Alternative nesting algorithms
    function nestBottomLeft(components, kerf, BL, BW) {
      // Simplified bottom-left algorithm
      let comps = components.slice().sort((a, b) => 
        (parseFloat(b["Length"]) * parseFloat(b["Width"])) - 
        (parseFloat(a["Length"]) * parseFloat(a["Width"]))
      );
      
      let sheets = [];
      
      while (comps.length) {
        let placed = [];
        let left = [];
        
        for (let c of comps) {
          let l = parseFloat(c["Length"]) || 0;
          let w = parseFloat(c["Width"]) || 0;
          
          // Find bottom-left position
          let bestX = 0, bestY = 0, canPlace = false;
          
          // Simple placement logic - can be enhanced
          for (let y = 0; y <= BW - w; y += 10) {
            for (let x = 0; x <= BL - l; x += 10) {
              let overlaps = placed.some(p => 
                !(x >= p.x + p.l + kerf || x + l + kerf <= p.x ||
                  y >= p.y + p.w + kerf || y + w + kerf <= p.y)
              );
              
              if (!overlaps) {
                bestX = x;
                bestY = y;
                canPlace = true;
                break;
              }
            }
            if (canPlace) break;
          }
          
          if (canPlace) {
            placed.push({
              x: bestX, y: bestY, l: l, w: w,
              comp: c, idx: c.__csvIndex, instance: c.__instance || 0
            });
          } else {
            left.push(c);
          }
        }
        
        sheets.push(placed);
        if (left.length === comps.length) break;
        comps = left;
      }
      
      return sheets;
    }

    function nestBestFit(components, kerf, BL, BW) {
      // Best-fit decreasing algorithm
      return nestMaximalRectangles(components, kerf, BL, BW); // Fallback to maxrect for now
    }

    // Progress Bar Functions
    function showProgress(percent, message) {
      const container = document.getElementById('progressContainer');
      const fill = document.getElementById('progressFill');
      const text = document.getElementById('progressText');
      
      container.style.display = 'block';
      fill.style.width = percent + '%';
      text.textContent = message || `Processing... ${Math.round(percent)}%`;
      
      if (percent >= 100) {
        setTimeout(() => {
          container.style.display = 'none';
        }, 1000);
      }
    }

    function hideProgress() {
      document.getElementById('progressContainer').style.display = 'none';
    }

    // Enhanced File Processing
    document.getElementById('processBtn').onclick = async function() {
      try {
        resetUI();
        showProgress(0, 'Starting processing...');
        
        const cutFile = document.getElementById('cuttingCsv').files[0];
        const masterFile = document.getElementById('masterCsv').files[0];
        
        if (!cutFile || !masterFile) {
          showError("Please select both CSV files.");
          hideProgress();
          return;
        }
        
        showProgress(5, 'Reading files...');
        
        // Read files
        const [masterText, cutText] = await Promise.all([
          readFileAsync(masterFile),
          readFileAsync(cutFile)
        ]);
        
        // Process master file
        showProgress(15, 'Processing board master...');
        await processMasterCSV(masterText);
        
        // Process cutting list
        showProgress(40, 'Processing cutting list...');
        await processCuttingCSV(cutText);
        
        showProgress(100, 'Complete!');
        showSuccess("Files processed successfully! Ready to generate cutting diagrams.");
        
        // Update UI
        updateTabsUI();
        updateHeaderButtons();
        
        // Auto-select first tab
        if (currentBoards.length > 0) {
          window.selectTab(0);
        }
        
      } catch (error) {
        console.error('Processing error:', error);
        showError(`Error processing files: ${error.message}`);
        hideProgress();
      }
    };

    function readFileAsync(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsText(file, 'utf-8');
      });
    }

    async function processMasterCSV(masterText) {
      const mRows = parseCSV(masterText);
      const mHeaders = mRows[0] || [];
      
      // Validate required headers
      const requiredHeaders = ["Material", "board length  ", "board width  "];
      const missingHeaders = requiredHeaders.filter(h => !mHeaders.includes(h));
      
      if (missingHeaders.length > 0) {
        throw new Error(`Board Master CSV missing required headers: ${missingHeaders.join(', ')}`);
      }
      
      let mObjs = buildObjects(mRows, mHeaders);
      masterBoardDB = {};
      
      mObjs.forEach(row => {
        let mat = (row["Material"]||"").trim();
        let len = parseFloat(row["board length  "]) || 0;
        let wid = parseFloat(row["board width  "]) || 0;
        
        if (mat && len > 0 && wid > 0) {
          masterBoardDB[mat] = {length: len, width: wid};
        }
      });
      
      if (Object.keys(masterBoardDB).length === 0) {
        throw new Error('No valid board definitions found in Master CSV');
      }
    }

    async function processCuttingCSV(csvText) {
      const rows = parseCSV(csvText);
      const headers = rows[0] || [];
      
      // Validate required headers
      const requiredHeaders = ["Name", "Length", "Width", "Material", "Quantity"];
      const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));
      
      if (missingHeaders.length > 0) {
        throw new Error(`Cutting List CSV missing required headers: ${missingHeaders.join(', ')}`);
      }
      
      let objs = buildObjects(rows, headers);
      originalParts = objs;
      
      // Validate data
      const invalidParts = objs.filter((obj, i) => {
        const length = parseFloat(obj["Length"]) || 0;
        const width = parseFloat(obj["Width"]) || 0;
        const material = (obj["Material"] || "").trim();
        const name = (obj["Name"] || "").trim();
        
        return !name || length <= 0 || width <= 0 || !material;
      });
      
      if (invalidParts.length > 0) {
        console.warn(`Found ${invalidParts.length} parts with invalid data`);
      }
      
      let boardGroups = groupByBoard(objs.filter(obj => {
        const length = parseFloat(obj["Length"]) || 0;
        const width = parseFloat(obj["Width"]) || 0;
        const material = (obj["Material"] || "").trim();
        const name = (obj["Name"] || "").trim();
        
        return name && length > 0 && width > 0 && material;
      }));
      
      let boards = Object.keys(boardGroups);
      currentBoards = boards;
      currentGroups = boardGroups;
      currentSheets = {};
      currentSheetPage = {};
      
      // Process each board type
      for (let i = 0; i < boards.length; i++) {
        const boardKey = boards[i];
        const mat = (boardKey || "").trim();
        const size = masterBoardDB[mat];
        const L = size ? size.length : 0;
        const W = size ? size.width : 0;
        
        boardSizes[boardKey] = {
          length: L, 
          width: W, 
          warn: (!L || !W)
        };
        
        if (L && W) {
          showProgress(50 + (i / boards.length) * 40, `Optimizing ${mat}...`);
          
          let comps = expandQuantities(boardGroups[boardKey]);
          let sheets = nestComponentsOnBoards(
            comps, 
            appSettings.kerfWidth, 
            L, 
            W, 
            appSettings.nestingAlgorithm
          );
          
          currentSheets[boardKey] = sheets;
          currentSheetPage[boardKey] = 0;
          
          // Build placement map
          let placement = {};
          sheets.forEach((sheet, pageIdx) => {
            sheet.forEach((p, pi) => {
              placement[`${p.idx}_${p.instance||0}`] = {page: pageIdx, pi: pi};
            });
          });
          partPlacementMap[boardKey] = placement;
          
          completedPages[boardKey] = Array(sheets.length).fill(false);
        }
      }
    }

    function resetUI() {
      document.getElementById('error').style.display = 'none';
      document.getElementById('success').style.display = 'none';
      document.getElementById('info').style.display = 'none';
      document.getElementById('tabs').innerHTML = '';
      document.getElementById('tab-content').innerHTML = '';
      document.getElementById('popup').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
      
      printedParts = {};
      partPlacementMap = {};
      resetZoom();
      completedPages = {};
      boardSizes = {};
    }

    function showError(message) {
      const el = document.getElementById('error');
      el.textContent = message;
      el.style.display = 'block';
      showNotification(message, 'error');
    }

    function showSuccess(message) {
      const el = document.getElementById('success');
      el.textContent = message;
      el.style.display = 'block';
      showNotification(message, 'success');
    }

    function showInfo(message) {
      const el = document.getElementById('info');
      el.textContent = message;
      el.style.display = 'block';
      showNotification(message, 'info');
    }

    function updateTabsUI() {
      let html = '';
      currentBoards.forEach((tab, i) => {
        let size = boardSizes[tab];
        let sizeStr = (size && size.length && size.width)
          ? `${size.length} × ${size.width} mm`
          : "<span class='warn'>⚠️ Not found in Board Master!</span>";
        
        // Calculate utilization
        let sheets = currentSheets[tab] || [];
        let totalParts = sheets.reduce((sum, sheet) => sum + sheet.length, 0);
        let utilization = 0;
        
        if (size && size.length && size.width) {
          let totalBoardArea = sheets.length * size.length * size.width;
          let totalPartArea = 0;
          sheets.forEach(sheet => {
            sheet.forEach(part => {
              totalPartArea += part.l * part.w;
            });
          });
          utilization = totalBoardArea > 0 ? (totalPartArea / totalBoardArea * 100) : 0;
        }
        
        html += `<div class="tab${i===0?" selected":""}" onclick="window.selectTab(${i})" id="tab${i}">
          <div><strong>${escapeHtml(tab)}</strong></div>
          <div style="font-size: 12px; margin-top: 4px;">${sizeStr}</div>
          <div style="font-size: 11px; margin-top: 2px; color: #666;">
            ${sheets.length} sheets • ${totalParts} parts • ${utilization.toFixed(1)}% used
          </div>
        </div>`;
      });
      document.getElementById('tabs').innerHTML = html;
    }

    function updateHeaderButtons() {
      document.getElementById('printAllBtn').style.display = 'inline-block';
      document.getElementById('exportPdfBtn').style.display = 'inline-block';
      document.getElementById('saveProjectBtn').style.display = 'inline-block';
      document.getElementById('testPrintBtn').style.display = 'inline-block';
      const printAllBtn = document.getElementById('printAllBtn');
      if (printAllBtn && !printAllBtn._wired) {
        printAllBtn.addEventListener('click', window.printAllSheets);
        printAllBtn._wired = true;
      }
    }

    function resetZoom() { 
      zoomLevel = 1; 
      panX = 0; 
      panY = 0; 
    }

    // Enhanced Tab Selection with Analytics
    window.selectTab = function(idx) {
      if (idx < 0 || idx >= currentBoards.length) return;
      
      // Update tab appearance
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('selected'));
      let t = document.getElementById('tab' + idx);
      if (t) t.classList.add('selected');
      
      let key = currentBoards[idx];
      let sheets = currentSheets[key] || [];
      let page = currentSheetPage[key] || 0;
      let comps = currentGroups[key] || [];
      
      let BL = (boardSizes[key] && boardSizes[key].length) ? boardSizes[key].length : null;
      let BW = (boardSizes[key] && boardSizes[key].width) ? boardSizes[key].width : null;
      let errorFlag = (!BL || !BW);
      
      renderMainView(key, page, sheets, BL, BW, errorFlag);
    };

    function renderMainView(key, page, sheets, BL, BW, errorFlag) {
      let svgW = 900, svgH = 700, PAD = 60;
      
      let html = `<div id="main-flex-row">
        <div id="svg-board-wrap">
          <div id="svg-board-inside">`;
      
      if (errorFlag) {
        html += `<div class="error">
          <h3>⚠️ Board Configuration Error</h3>
          <p>Board size not found in master CSV for <strong>${escapeHtml(key)}</strong>.</p>
          <p>Please verify that the material name matches exactly between your cutting list and board master files.</p>
        </div>`;
      } else {
        html += renderSVGDiagram(key, page, sheets, BL, BW, svgW, svgH, PAD);
      }
      
      html += `</div></div>
        <div id="divider"></div>
        <div id="side-table">`;
      
      html += renderSidePanel(key, page, sheets, errorFlag);
      
      html += `</div></div>`;
      
      // Add controls
      html += renderControls(key, sheets, page, errorFlag);
      
      document.getElementById('tab-content').innerHTML = html;
      
      // Initialize interactions
      setTimeout(() => initializeInteractions(svgW, svgH), 100);
    }

    function renderSVGDiagram(key, page, sheets, BL, BW, svgW, svgH, PAD) {
      let scale = Math.min((svgW - PAD * 2) / BL, (svgH - PAD * 2) / BW);
      let parts = sheets[page] || [];
      
      let html = `<div class="svg-container">
        <svg id="svgMain" width="${svgW}" height="${svgH}" tabindex="0">
          <defs>
            <pattern id="gridPattern" width="20" height="20" patternUnits="userSpaceOnUse">
              <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#f0f0f0" stroke-width="1"/>
            </pattern>
            <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
              <feDropShadow dx="2" dy="2" stdDeviation="2" flood-opacity="0.3"/>
            </filter>
          </defs>
          <g id="svgPan" transform="scale(${zoomLevel}) translate(${panX},${panY})">
            <rect width="${svgW}" height="${svgH}" fill="url(#gridPattern)"/>
            <rect x="${PAD}" y="${PAD}" width="${BL*scale}" height="${BW*scale}" 
                  fill="#ffffff" stroke="#2563eb" stroke-width="3" 
                  filter="url(#shadow)" rx="4"/>
            
            <!-- Board dimensions -->
            <text x="${PAD + BL*scale/2}" y="${PAD-15}" font-size="20" font-weight="bold"
                  fill="#2563eb" text-anchor="middle">${BL} mm</text>
            <text x="${PAD-20}" y="${PAD + BW*scale/2+7}" font-size="20" font-weight="bold"
                  fill="#2563eb" text-anchor="middle" 
                  transform="rotate(-90,${PAD-20},${PAD + BW*scale/2+7})">${BW} mm</text>`;
      
      // Draw cutting guides
      let vCuts = new Set(), hCuts = new Set();
      parts.forEach(p => {
        vCuts.add(p.x); vCuts.add(p.x + p.l);
        hCuts.add(p.y); hCuts.add(p.y + p.w);
      });
      
      vCuts.forEach(x => {
        if (x !== 0 && x !== BL) {
          html += `<line x1="${PAD + x*scale}" y1="${PAD}" 
                        x2="${PAD + x*scale}" y2="${PAD + BW*scale}" 
                        stroke="#94a3b8" stroke-width="2" stroke-dasharray="8,4" opacity="0.7"/>`;
        }
      });
      
      hCuts.forEach(y => {
        if (y !== 0 && y !== BW) {
          html += `<line x1="${PAD}" y1="${PAD + y*scale}" 
                        x2="${PAD + BL*scale}" y2="${PAD + y*scale}" 
                        stroke="#94a3b8" stroke-width="2" stroke-dasharray="8,4" opacity="0.7"/>`;
        }
      });
      
      // Draw parts
      parts.forEach((p, n) => {
        let pKey = `${key}_${page}_${n}`;
        let isPrinted = printedParts[pKey];
        let fillCol = isPrinted ? '#3b82f6' : '#fbbf24'; // Blue if printed, yellow if not
        let strokeCol = isPrinted ? '#1e40af' : '#92400e'; // Dark blue if printed
        
        // Calculate text sizes
        let availableW = p.l * scale;
        let availableH = p.w * scale;
        let baseNameFont = Math.max(Math.min(availableW / 8, availableH / 3, 24), 10);
        let nameFont = Math.round(baseNameFont);
        let dimFont = Math.round(nameFont * 0.8);
        
        html += `<g class="part-group" data-part-index="${n}">
          <rect x="${PAD + p.x*scale}" y="${PAD + p.y*scale}" 
                width="${p.l*scale}" height="${p.w*scale}" 
                fill="${fillCol}" stroke="${strokeCol}" stroke-width="2" 
                cursor="pointer" filter="url(#shadow)" rx="2"
                onclick="window.highlightComponent('${key}',${page},${n})"
                data-svg-part="${key}_${page}_${n}"
                ${printedParts[pKey] ? 'data-printed="true"' : ''}
                onmouseover="this.style.opacity='0.8'" 
                onmouseout="this.style.opacity='1'"/>`;
        
        // Part name (centered)
        if (availableW > 40 && availableH > 20) {
          html += `<text x="${PAD + p.x*scale + availableW/2}" 
                        y="${PAD + p.y*scale + availableH/2 - dimFont/2}" 
                        font-size="${nameFont}" font-weight="600" font-family="Arial" 
                        fill="#1f2937" text-anchor="middle">${escapeHtml(p.comp["Name"])}</text>`;
        }
        
        // Dimensions
        if (availableW > 60 && availableH > 35) {
          let isLongX = p.l >= p.w;
          if (isLongX) {
            html += `<text x="${PAD + p.x*scale + availableW/2}" 
                          y="${PAD + p.y*scale + 18}" 
                          font-size="${dimFont}" font-weight="500" fill="#374151" 
                          text-anchor="middle">${p.l}mm</text>`;
            html += `<text x="${PAD + p.x*scale + 15}" 
                          y="${PAD + p.y*scale + availableH/2}" 
                          font-size="${dimFont}" font-weight="500" fill="#374151" 
                          text-anchor="middle" 
                          transform="rotate(-90,${PAD + p.x*scale + 15},${PAD + p.y*scale + availableH/2})">${p.w}mm</text>`;
          } else {
            html += `<text x="${PAD + p.x*scale + 15}" 
                          y="${PAD + p.y*scale + availableH/2}" 
                          font-size="${dimFont}" font-weight="500" fill="#374151" 
                          text-anchor="middle" 
                          transform="rotate(-90,${PAD + p.x*scale + 15},${PAD + p.y*scale + availableH/2})">${p.l}mm</text>`;
            html += `<text x="${PAD + p.x*scale + availableW/2}" 
                          y="${PAD + p.y*scale + 18}" 
                          font-size="${dimFont}" font-weight="500" fill="#374151" 
                          text-anchor="middle">${p.w}mm</text>`;
          }
        }
        
        // Status indicator
        html += `<circle cx="${PAD + p.x*scale + availableW - 12}" 
                        cy="${PAD + p.y*scale + 12}" r="6" 
                        fill="${isPrinted ? '#10b981' : '#f59e0b'}" 
                        stroke="white" stroke-width="2"/>`;
        
        html += `</g>`;
      });
      
      html += `</g></svg></div>`;
      return html;
    }

    function renderSidePanel(key, page, sheets, errorFlag) {
      let html = `<div class="side-header">
        📋 Sheet ${page + 1} Components
        ${sheets.length > 0 ? `<span style="font-size: 14px; font-weight: normal; color: #6b7280;">(${(sheets[page] || []).length} parts)</span>` : ''}
      </div>`;
      
      if (!errorFlag && sheets.length > 0) {
        let parts = sheets[page] || [];
        let totalArea = 0;
        let boardSize = boardSizes[key];
        let sheetArea = boardSize ? boardSize.length * boardSize.width : 0;
        
        parts.forEach((p, n) => {
          totalArea += p.l * p.w;
          let comp = p.comp;
          let pKey = `${key}_${page}_${n}`;
          let isPrinted = printedParts[pKey];
          
        html += `<div class="side-part-row" data-part-id="${pKey}" onclick="window.highlightComponent('${key}',${page},${n})">
            <div class="side-part-info">
              <div class="side-part-name">
                <span class="status-indicator ${isPrinted ? 'printed' : 'pending'}"></span>
                ${escapeHtml(comp["Name"])}
                ${p.rotated ? '<span style="color: #f59e0b; font-size: 11px;"> ↻</span>' : ''}
              </div>
              <div class="side-part-dim">${p.l} × ${p.w} mm</div>
              ${comp["Quantity"] && parseInt(comp["Quantity"]) > 1 ? 
                `<div style="font-size: 11px; color: #6b7280;">Qty: ${comp["Quantity"]}</div>` : ''}
            </div>
            <button class="side-print-btn" 
                    onclick="window.showComponentPopup('${key}',${page},${n}); event.stopPropagation();">
              🏷️ Label
            </button>
          </div>`;
        });
        
        // Sheet statistics
        let utilization = sheetArea > 0 ? (totalArea / sheetArea * 100) : 0;
        let wasteArea = sheetArea - totalArea;
        
        html += `<div style="margin-top: 20px; padding-top: 15px; border-top: 2px solid var(--border-color);">
          <div class="side-header" style="font-size: 14px; margin-bottom: 10px;">📊 Sheet Statistics</div>
          <div style="font-size: 12px; color: #6b7280; line-height: 1.6;">
            <div><strong>Material Utilization:</strong> ${utilization.toFixed(1)}%</div>
            <div><strong>Used Area:</strong> ${(totalArea/1000000).toFixed(3)} m²</div>
            <div><strong>Waste Area:</strong> ${(wasteArea/1000000).toFixed(3)} m²</div>
            <div><strong>Parts Count:</strong> ${parts.length}</div>
          </div>
        </div>`;
        
        // Potential offcuts
        if (wasteArea > appSettings.minOffcutL * appSettings.minOffcutW) {
          html += `<div style="margin-top: 15px;">
            <div style="font-size: 12px; color: #059669; font-weight: 600;">
              💡 Usable offcuts available (≥${appSettings.minOffcutL}×${appSettings.minOffcutW}mm)
            </div>
          </div>`;
        }
      }
      
      return html;
    }

    function renderControls(key, sheets, page, errorFlag) {
      let html = `<div class="controls-row">
        <div class="page-btns">
          <span style="margin-right: 15px; font-weight: 600; color: var(--primary-color);">📄 Sheets:</span>`;
      
      if (!errorFlag && sheets.length > 0) {
        sheets.forEach((sheet, i) => {
          let selected = (i === page) ? 'selected' : '';
          let complete = completedPages[key] && completedPages[key][i] ? 'complete' : '';
          let partCount = sheet.length;
          
          html += `<div class="sheet-col">
            <button class="sheet-btn ${selected} ${complete}" 
                    onclick="window.goToSheet('${key}',${i})" 
                    title="Sheet ${i+1} - ${partCount} parts">
              ${i + 1}
            </button>
            <button class="done-btn${complete ? ' done' : ''}" 
                    onclick="window.completeCurrentSheet('${key}',${i})"
                    title="${complete ? 'Mark as incomplete' : 'Mark as complete'}">
              ${complete ? '✓' : '○'}
            </button>
          </div>`;
        });
      }
      
      html += `<div style="margin-left: 20px; color: #6b7280; font-size: 14px;">
          <strong>Page ${page + 1} of ${sheets.length || 1}</strong>
        </div>
        <button class="reset-btn" onclick="window.resetAllComplete()" title="Reset all completion status">
          🔄 Reset All
        </button>
      </div>
      
      <div class="zoom-controls">
        <button class="zoom-btn" onclick="window.zoomSvg(-1)" title="Zoom out (-)">🔍−</button>
        <button class="zoom-btn" onclick="window.zoomSvg(1)" title="Zoom in (+)">🔍+</button>
        <button class="zoom-btn" onclick="window.resetSvgPanZoom()" title="Reset view (R)">🎯</button>
        <span style="margin-left: 15px; font-size: 12px; color: #6b7280;">
          Zoom: ${Math.round(zoomLevel * 100)}%
        </span>
      </div>
    </div>`;
      
      return html;
    }
    // Component click handler - just highlight, don't show popup
    window.highlightComponent = function(boardKey, pageIdx, pi) {
      // Remove all existing highlights
      document.querySelectorAll('.side-part-row').forEach(row => {
        row.style.background = 'white';
      });
      document.querySelectorAll('.part-group rect').forEach(rect => {
        if (!rect.dataset.printed) {
          rect.setAttribute('fill', '#fbbf24');
        }
      });
      
      // Highlight the clicked component
      let partId = `${boardKey}_${pageIdx}_${pi}`;
      let sideRow = document.querySelector(`[data-part-id="${partId}"]`);
      if (sideRow) {
        sideRow.style.background = '#10b981';
      }
      
      let svgRect = document.querySelector(`[data-svg-part="${partId}"]`);
      if (svgRect && !svgRect.dataset.printed) {
        svgRect.setAttribute('fill', '#10b981');
      }
    };

    // Enhanced Component Popup with Zebra Printing
    window.showComponentPopup = function(boardKey, pageIdx, pi) {
      let sheets = currentSheets[boardKey];
      let parts = sheets[pageIdx];
      let p = parts[pi];
      let comp = p.comp;
      
      let boardType = (boardKey || "").trim();
      let size = boardSizes[boardKey];
      let boardSize = size ? `${size.length} × ${size.width} mm` : "N/A";
      
      let l = parseFloat(comp["Length"]) || 0;
      let w = parseFloat(comp["Width"]) || 0;
      let el1 = comp["Edging Length 1"] || "";
      let el2 = comp["Edging Length 2"] || "";
      let ew1 = comp["Edging Width 1"] || "";
      let ew2 = comp["Edging Width 2"] || "";
      
      // Enhanced visual representation
      let rectW = 120, rectH = 80;
      let svg = `<svg width="150" height="100" style="border: 1px solid #e2e8f0; border-radius: 8px; background: #f8fafc;">
        <rect x="15" y="10" width="${rectW}" height="${rectH}" fill="#ffffff" stroke="#2563eb" stroke-width="2" rx="4"/>
        ${el1 ? `<line x1="15" y1="10" x2="${15+rectW}" y2="10" stroke="#ef4444" stroke-width="4"/>` : ''}
        ${el2 ? `<line x1="15" y1="${10+rectH}" x2="${15+rectW}" y2="${10+rectH}" stroke="#ef4444" stroke-width="4"/>` : ''}
        ${ew1 ? `<line x1="15" y1="10" x2="15" y2="${10+rectH}" stroke="#ef4444" stroke-width="4"/>` : ''}
        ${ew2 ? `<line x1="${15+rectW}" y1="10" x2="${15+rectW}" y2="${10+rectH}" stroke="#ef4444" stroke-width="4"/>` : ''}
        <text x="${15 + rectW/2}" y="${10 + rectH/2 + 3}" font-size="12" font-weight="bold" text-anchor="middle" fill="#1f2937">${l}×${w}</text>
        ${p.rotated ? `<text x="${15 + rectW - 20}" y="25" font-size="16" fill="#f59e0b">↻</text>` : ''}
      </svg>`;
      
      let html = `<div class="popup-header">
        <h3>🏷️ Component Label</h3>
        <span class="close-btn" onclick="window.hidePopup()">&times;</span>
      </div>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
        <div>
          <h4 style="margin: 0 0 10px 0; color: var(--primary-color);">📋 Component Details</h4>
          <div style="font-size: 14px; line-height: 1.6;">
            <div><strong>Name:</strong> ${escapeHtml(comp["Name"])}</div>
            <div><strong>Dimensions:</strong> ${l} × ${w} mm</div>
            <div><strong>Material:</strong> ${escapeHtml(boardType)}</div>
            <div><strong>Board Size:</strong> ${escapeHtml(boardSize)}</div>
            ${comp["Quantity"] ? `<div><strong>Quantity:</strong> ${comp["Quantity"]}</div>` : ''}
            ${p.rotated ? '<div style="color: #f59e0b;"><strong>⚠️ Rotated for optimization</strong></div>' : ''}
          </div>
        </div>
        
        <div style="text-align: center;">
          <h4 style="margin: 0 0 10px 0; color: var(--primary-color);">📐 Visual Preview</h4>
          ${svg}
        </div>
      </div>
      
      <div style="margin-bottom: 20px;">
        <h4 style="margin: 0 0 10px 0; color: var(--primary-color);">🎨 Edge Banding</h4>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">
          <div><strong>Length 1:</strong> ${escapeHtml(el1) || 'None'}</div>
          <div><strong>Length 2:</strong> ${escapeHtml(el2) || 'None'}</div>
          <div><strong>Width 1:</strong> ${escapeHtml(ew1) || 'None'}</div>
          <div><strong>Width 2:</strong> ${escapeHtml(ew2) || 'None'}</div>
        </div>
      </div>
      
      <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
        <button id="printLabelBtn" class="action-btn" style="background: var(--primary-color);">
          🖨️ Print Label (Browser)
        </button>
        <button id="zebraLabelBtn" class="action-btn" style="background: var(--success-color);" ${!zebraPrinter ? 'disabled' : ''}>
          ⚡ Zebra Print ${!zebraPrinter ? '(Not Connected)' : ''}
        </button>
        <button id="undoPrintBtn" class="action-btn" style="background: var(--warning-color);">
          ↶ Undo Print Status
        </button>
      </div>
      
      ${!zebraPrinter ? '<div class="info" style="margin-top: 15px; font-size: 12px;">💡 Connect Zebra printer for direct printing</div>' : ''}`;
      
      document.getElementById('popup').innerHTML = html;
      document.getElementById('popup').style.display = "block";
      document.getElementById('overlay').style.display = "block";
      
      // Browser print handler
      document.getElementById('printLabelBtn').onclick = function() {
        printBrowserLabel(comp, boardType, l, w, el1, el2, ew1, ew2, svg);
        markPartAsPrinted(boardKey, pageIdx, pi);
      };
      
      // Zebra print handler
      document.getElementById('zebraLabelBtn').onclick = function() {
        if (!zebraPrinter) {
          showNotification('Zebra printer not connected', 'error');
          return;
        }
        
        printZebraLabel(comp, boardType, l, w, { el1, el2, ew1, ew2 });
        markPartAsPrinted(boardKey, pageIdx, pi);
      };
      // Undo print handler
      document.getElementById('undoPrintBtn').onclick = function() {
        let partKey = `${boardKey}_${pageIdx}_${pi}`;
        delete printedParts[partKey];
        
        // Reset SVG color
        let svgRect = document.querySelector(`[data-svg-part="${partKey}"]`);
        if (svgRect) {
          svgRect.setAttribute('fill', '#fbbf24');
          delete svgRect.dataset.printed;
        }
        
        // Reset side panel
        let sideRow = document.querySelector(`[data-part-id="${partKey}"]`);
        if (sideRow) {
          sideRow.style.background = 'white';
          let indicator = sideRow.querySelector('.status-indicator');
          if (indicator) {
            indicator.classList.remove('printed');
            indicator.classList.add('pending');
          }
        }
        
        window.hidePopup();
        showNotification('Print status removed', 'info');
      };
    };

  function printBrowserLabel(comp, material, length, width, el1, el2, ew1, ew2, svg) {
      // Open a dedicated print-only window so the preview contains only the label
      const w = window.open('', '_blank', 'noopener,noreferrer,width=900,height=700');
      if (!w) {
        showNotification('Popup blocked: enable popups to print the label', 'error');
        return;
      }

      // Determine label size in inches from settings
      let size = (appSettings.labelSize || '4x2').toLowerCase();
      let labelWIn = 4, labelHIn = 2;
      if (size === '4x3') { labelWIn = 4; labelHIn = 3; }
      else if (size === '4x6') { labelWIn = 4; labelHIn = 6; }

      const labelMarginMm = Number(appSettings.labelMargin) || 6;
      const titleFontPx = Number(appSettings.labelFontSize) || 18;
      const titleWeight = appSettings.labelBold ? '700' : '400';

      const notesHtml = (comp["Notes 1"] || comp["Notes 2"]) ? (
        '<div class="notes">' +
        (comp["Notes 1"] ? `<div><strong>Note 1:</strong> ${escapeHtml(comp["Notes 1"])}</div>` : '') +
        (comp["Notes 2"] ? `<div><strong>Note 2:</strong> ${escapeHtml(comp["Notes 2"])}</div>` : '') +
        '</div>'
      ) : '';

      const edgesText = (el1 || el2 || ew1 || ew2)
        ? `Edge: L1:${escapeHtml(el1||'')} L2:${escapeHtml(el2||'')} W1:${escapeHtml(ew1||'')} W2:${escapeHtml(ew2||'')}`
        : 'No edging';

      const html = '<!DOCTYPE html>' +
        '<html>' +
          '<head>' +
            '<meta charset="utf-8" />' +
            '<title>Label - ' + escapeHtml(comp["Name"] || '') + '</title>' +
            '<style>' +
              '@page { size: ' + labelWIn + 'in ' + labelHIn + 'in; margin: 0; }' +
              'html, body { height: 100%; }' +
              'body { margin: 0; font-family: Arial, sans-serif; }' +
              '.label { box-sizing: border-box; width: ' + labelWIn + 'in; height: ' + labelHIn + 'in; padding: ' + labelMarginMm + 'mm; background: #ffffff; color: #000; border: 2px solid #000; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; }' +
              '.title { text-align: center; font-size: ' + titleFontPx + 'px; font-weight: ' + titleWeight + '; margin-bottom: 8px; }' +
              '.center { text-align: center; }' +
              '.dim { font-size: 14px; margin-bottom: 6px; font-weight: 700; }' +
              '.material { font-size: 12px; margin-bottom: 4px; }' +
              '.edge { font-size: 11px; }' +
              '.notes { font-size: 11px; margin-top: 6px; width: 100%; }' +
              '.notes div { margin-top: 2px; }' +
              '.preview { margin-bottom: 8px; }' +
              '.preview svg { max-width: 100%; height: auto; }' +
              '@media print { .label { page-break-after: always; } }' +
            '</style>' +
          '</head>' +
          '<body>' +
            '<div class="label">' +
              '<div class="title">' + escapeHtml(comp["Name"] || '') + '</div>' +
              '<div class="center preview">' + svg + '</div>' +
              '<div class="dim"><strong>' + length + ' × ' + width + ' mm</strong></div>' +
              '<div class="material">' + escapeHtml(material || '') + '</div>' +
              '<div class="edge">' + edgesText + '</div>' +
              notesHtml +
            '</div>' +
            '<script>window.addEventListener("load",function(){setTimeout(function(){try{window.print();}finally{window.close();}},50);});</scr' + 'ipt>' +
          '</body>' +
        '</html>';

      w.document.open();
      w.document.write(html);
      w.document.close();

      showNotification('Opening label print dialog...', 'success');
    }

  function printZebraLabel(comp, material, length, width, edging) {
      const zplData = generateZT230ZPL({
        name: comp["Name"] || '',
        length: length,
        width: width,
        material: material,
        edging: edging,
        notes1: comp["Notes 1"] || '',
        notes2: comp["Notes 2"] || ''
      }, appSettings);
      
      console.log('Sending ZPL to Zebra:', zplData);
      
      zebraPrinter.send(zplData, function(success) {
        showNotification('Label printed successfully on Zebra printer!', 'success');
      }, function(error) {
        console.error('Zebra print error:', error);
        showNotification(`Zebra print error: ${error}`, 'error');
      });
    }

  function markPartAsPrinted(boardKey, pageIdx, pi) {
      let partKey = `${boardKey}_${pageIdx}_${pi}`;
      printedParts[partKey] = true;
      
      // Update SVG to blue
      let svgRect = document.querySelector(`[data-svg-part="${partKey}"]`);
      if (svgRect) {
        svgRect.setAttribute('fill', '#3b82f6'); // Blue color
        svgRect.dataset.printed = 'true';
      }
      
      // Update side panel to blue
      let sideRow = document.querySelector(`[data-part-id="${partKey}"]`);
      if (sideRow) {
        sideRow.style.background = '#dbeafe'; // Light blue background
        let indicator = sideRow.querySelector('.status-indicator');
        if (indicator) {
          indicator.classList.remove('pending');
          indicator.classList.add('printed');
        }
      }
      
      window.hidePopup();
      // Refresh the current view to reflect updated styles and status indicators
      const currentTabIndex = Array.from(document.querySelectorAll('.tab')).findIndex(t => t.classList.contains('selected'));
      if (currentTabIndex >= 0) {
        window.selectTab(currentTabIndex);
      }
    }
      
    

    // Navigation Functions
    window.goToSheet = function(key, pageIdx) {
      resetZoom();
      currentSheetPage[key] = pageIdx;
      let tabIndex = currentBoards.indexOf(key);
      if (tabIndex >= 0) {
        window.selectTab(tabIndex);
      }
    };

    window.completeCurrentSheet = function(key, pageIdx) {
      if (!completedPages[key]) completedPages[key] = [];
      completedPages[key][pageIdx] = !completedPages[key][pageIdx]; // Toggle
      
      let tabIndex = currentBoards.indexOf(key);
      if (tabIndex >= 0) {
        window.selectTab(tabIndex);
      }
      
      showNotification(
        completedPages[key][pageIdx] ? 'Sheet marked as complete' : 'Sheet marked as incomplete',
        'info'
      );
    };

    window.resetAllComplete = function() {
      Object.keys(completedPages).forEach(key => {
        if (completedPages[key]) {
          completedPages[key] = completedPages[key].map(() => false);
        }
      });
      
      let currentTabIndex = Array.from(document.querySelectorAll('.tab')).findIndex(t => t.classList.contains('selected'));
      if (currentTabIndex >= 0) {
        window.selectTab(currentTabIndex);
      }
      
      showNotification('All completion status reset', 'info');
    };

    // Zoom and Pan Functions
    window.zoomSvg = function(dir) {
      let oldZoom = zoomLevel;
      if (dir > 0) zoomLevel *= 1.2;
      else zoomLevel *= 0.8;
      
      if (zoomLevel < 0.1) zoomLevel = 0.1;
      if (zoomLevel > 10) zoomLevel = 10;
      
      let panGroup = document.getElementById('svgPan');
      if (panGroup) {
        panGroup.setAttribute('transform', `scale(${zoomLevel}) translate(${panX},${panY})`);
      }
      
      // Update zoom display
      let zoomDisplay = document.querySelector('.zoom-controls span');
      if (zoomDisplay) {
        zoomDisplay.textContent = `Zoom: ${Math.round(zoomLevel * 100)}%`;
      }
    };

    window.resetSvgPanZoom = function() {
      zoomLevel = 1;
      panX = 0;
      panY = 0;
      
      let panGroup = document.getElementById('svgPan');
      if (panGroup) {
        panGroup.setAttribute('transform', `scale(${zoomLevel}) translate(${panX},${panY})`);
      }
      
      // Update zoom display
      let zoomDisplay = document.querySelector('.zoom-controls span');
      if (zoomDisplay) {
        zoomDisplay.textContent = `Zoom: ${Math.round(zoomLevel * 100)}%`;
      }
    };

    // Initialize interactions (drag, zoom, etc.)
    function initializeInteractions(svgW, svgH) {
      initializePanelResize();
      initializeSVGInteractions();
    }

    function initializePanelResize() {
      let dragging = false;
      let mainRow = document.getElementById('main-flex-row');
      let divider = document.getElementById('divider');
      let left = document.getElementById('svg-board-wrap');
      let right = document.getElementById('side-table');
      
      if (!divider || !mainRow || !left || !right) return;
      
      divider.onmousedown = function(e) {
        dragging = true;
        document.body.style.cursor = "ew-resize";
        e.preventDefault();
      };
      
      document.onmousemove = function(e) {
        if (!dragging) return;
        
        let bounds = mainRow.getBoundingClientRect();
        let x = e.clientX - bounds.left;
        let minWidth = 300;
        let maxWidth = bounds.width - 300;
        
        if (x < minWidth) x = minWidth;
        if (x > maxWidth) x = maxWidth;
        
        let leftPercent = (x / bounds.width) * 100;
        let rightPercent = 100 - leftPercent;
        
        left.style.width = leftPercent + '%';
        right.style.width = rightPercent + '%';
      };
      
      document.onmouseup = function() {
        dragging = false;
        document.body.style.cursor = "";
      };
      
      // Touch support
      divider.ontouchstart = function(e) {
        dragging = true;
        e.preventDefault();
      };
      
      document.ontouchmove = function(e) {
        if (!dragging) return;
        
        let touch = e.touches[0];
        let bounds = mainRow.getBoundingClientRect();
        let x = touch.clientX - bounds.left;
        let minWidth = 250;
        let maxWidth = bounds.width - 250;
        
        if (x < minWidth) x = minWidth;
        if (x > maxWidth) x = maxWidth;
        
        let leftPercent = (x / bounds.width) * 100;
        let rightPercent = 100 - leftPercent;
        
        left.style.width = leftPercent + '%';
        right.style.width = rightPercent + '%';
        
        e.preventDefault();
      };
      
      document.ontouchend = function() {
        dragging = false;
      };
    }

    function initializeSVGInteractions() {
      let svg = document.getElementById('svgMain');
      if (!svg) return;
      
      let dragging = false;
      let lastX = 0, lastY = 0;
      
      // Mouse events
      svg.onmousedown = function(e) {
        // Don't pan when clicking on parts
        if (e.target.closest('.part-group')) return;
        
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        svg.style.cursor = 'grabbing';
        e.preventDefault();
      };
      
      svg.onmouseup = function(e) {
        dragging = false;
        svg.style.cursor = 'grab';
      };
      
      svg.onmouseleave = function(e) {
        dragging = false;
        svg.style.cursor = 'grab';
      };
      
      svg.onmousemove = function(e) {
        if (dragging) {
          let deltaX = (e.clientX - lastX) / zoomLevel;
          let deltaY = (e.clientY - lastY) / zoomLevel;
          
          panX += deltaX;
          panY += deltaY;
          
          lastX = e.clientX;
          lastY = e.clientY;
          
          let panGroup = document.getElementById('svgPan');
          if (panGroup) {
            panGroup.setAttribute('transform', `scale(${zoomLevel}) translate(${panX},${panY})`);
          }
        }
      };
      
      // Wheel zoom
      svg.onwheel = function(e) {
        e.preventDefault();
        
        let rect = svg.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        
        let oldZoom = zoomLevel;
        let zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
        zoomLevel *= zoomFactor;
        
        if (zoomLevel < 0.1) zoomLevel = 0.1;
        if (zoomLevel > 10) zoomLevel = 10;
        
        // Adjust pan to zoom towards mouse position
        let scale = zoomLevel / oldZoom;
        panX = x / oldZoom - (x / oldZoom - panX) * scale;
        panY = y / oldZoom - (y / oldZoom - panY) * scale;
        
        let panGroup = document.getElementById('svgPan');
        if (panGroup) {
          panGroup.setAttribute('transform', `scale(${zoomLevel}) translate(${panX},${panY})`);
        }
        
        // Update zoom display
        let zoomDisplay = document.querySelector('.zoom-controls span');
        if (zoomDisplay) {
          zoomDisplay.textContent = `Zoom: ${Math.round(zoomLevel * 100)}%`;
        }
      };
      
      // Touch events for mobile
      let touchStartX = 0, touchStartY = 0;
      let initialDistance = 0;
      let initialZoom = 1;
      
      svg.ontouchstart = function(e) {
        if (e.touches.length === 1) {
          // Single touch - pan
          dragging = true;
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          // Two touches - zoom
          dragging = false;
          let dx = e.touches[0].clientX - e.touches[1].clientX;
          let dy = e.touches[0].clientY - e.touches[1].clientY;
          initialDistance = Math.sqrt(dx * dx + dy * dy);
          initialZoom = zoomLevel;
        }
        e.preventDefault();
      };
      
      svg.ontouchmove = function(e) {
        if (e.touches.length === 1 && dragging) {
          // Pan
          let deltaX = (e.touches[0].clientX - touchStartX) / zoomLevel;
          let deltaY = (e.touches[0].clientY - touchStartY) / zoomLevel;
          
          panX += deltaX;
          panY += deltaY;
          
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          
          let panGroup = document.getElementById('svgPan');
          if (panGroup) {
            panGroup.setAttribute('transform', `scale(${zoomLevel}) translate(${panX},${panY})`);
          }
        } else if (e.touches.length === 2) {
          // Zoom
          let dx = e.touches[0].clientX - e.touches[1].clientX;
          let dy = e.touches[0].clientY - e.touches[1].clientY;
          let distance = Math.sqrt(dx * dx + dy * dy);
          
          zoomLevel = initialZoom * (distance / initialDistance);
          if (zoomLevel < 0.1) zoomLevel = 0.1;
          if (zoomLevel > 10) zoomLevel = 10;
          
          let panGroup = document.getElementById('svgPan');
          if (panGroup) {
            panGroup.setAttribute('transform', `scale(${zoomLevel}) translate(${panX},${panY})`);
          }
        }
        e.preventDefault();
      };
      
      svg.ontouchend = function(e) {
        dragging = false;
        e.preventDefault();
      };
    }

    // Popup management
    window.hidePopup = function() {
      document.getElementById('popup').style.display = "none";
      document.getElementById('overlay').style.display = "none";
    };

    // Print all sheets function
    window.printAllSheets = function() {
      let currentTabIndex = Array.from(document.querySelectorAll('.tab')).findIndex(t => t.classList.contains('selected'));
      if (currentTabIndex < 0) return;
      
      let key = currentBoards[currentTabIndex];
      let sheets = currentSheets[key];
      let BL = (boardSizes[key] && boardSizes[key].length) ? boardSizes[key].length : null;
      let BW = (boardSizes[key] && boardSizes[key].width) ? boardSizes[key].width : null;
      
      if (!sheets || !BL || !BW) {
        showNotification('Cannot print: Invalid board configuration', 'error');
        return;
      }
      
      showNotification('Preparing print pages...', 'info');
      
      let PAD = 60;
      let scale = Math.min((900 - PAD * 2) / BL, (700 - PAD * 2) / BW);
      let pagesHTML = "";
      
      sheets.forEach((parts, page) => {
        pagesHTML += generatePrintPage(key, page, parts, BL, BW, scale, PAD);
      });
      
      let holder = document.getElementById('printPagesHolder');
      holder.innerHTML = pagesHTML;
      holder.style.display = "block";
      
      setTimeout(() => {
        window.print();
        holder.style.display = "none";
        showNotification('Print dialog opened', 'success');
      }, 500);
    };

    function generatePrintPage(boardKey, pageIndex, parts, BL, BW, scale, PAD) {
      let html = `<div class="print-page" style="margin-bottom: 50px; page-break-after: always;">
        <div style="margin-bottom: 15px; text-align: center;">
          <h2 style="margin: 0; color: #1f2937;">Cutting Diagram - ${escapeHtml(boardKey)}</h2>
          <div style="margin-top: 8px; color: #6b7280;">
            Sheet ${pageIndex + 1} | Board Size: ${BL} × ${BW} mm | Parts: ${parts.length}
          </div>
          <div style="margin-top: 4px; font-size: 12px; color: #9ca3af;">
            Generated: ${new Date().toLocaleString()}
          </div>
        </div>`;
      
      // SVG diagram
      html += `<svg class="print-svg" width="900" height="700" style="border: 2px solid #374151; display: block; margin: 0 auto 20px auto;">
        <rect x="${PAD}" y="${PAD}" width="${BL*scale}" height="${BW*scale}" 
              fill="#ffffff" stroke="#1f2937" stroke-width="3"/>
        
        <!-- Board dimensions -->
        <text x="${PAD + BL*scale/2}" y="${PAD-15}" font-size="18" font-weight="bold"
              fill="#1f2937" text-anchor="middle">${BL} mm</text>
        <text x="${PAD-20}" y="${PAD + BW*scale/2+7}" font-size="18" font-weight="bold"
              fill="#1f2937" text-anchor="middle" 
              transform="rotate(-90,${PAD-20},${PAD + BW*scale/2+7})">${BW} mm</text>`;
      
      // Draw cutting guides
      let vCuts = new Set(), hCuts = new Set();
      parts.forEach(p => {
        vCuts.add(p.x); vCuts.add(p.x + p.l);
        hCuts.add(p.y); hCuts.add(p.y + p.w);
      });
      
      vCuts.forEach(x => {
        if (x !== 0 && x !== BL) {
          html += `<line x1="${PAD + x*scale}" y1="${PAD}" 
                        x2="${PAD + x*scale}" y2="${PAD + BW*scale}" 
                        stroke="#6b7280" stroke-width="1" stroke-dasharray="5,5"/>`;
        }
      });
      
      hCuts.forEach(y => {
        if (y !== 0 && y !== BW) {
          html += `<line x1="${PAD}" y1="${PAD + y*scale}" 
                        x2="${PAD + BL*scale}" y2="${PAD + y*scale}" 
                        stroke="#6b7280" stroke-width="1" stroke-dasharray="5,5"/>`;
        }
      });
      
      // Draw parts
      parts.forEach((p, n) => {
        let availableW = p.l * scale;
        let availableH = p.w * scale;
        let nameFont = Math.max(Math.min(availableW / 10, availableH / 4, 16), 8);
        let dimFont = Math.max(Math.min(nameFont * 0.8, 12), 7);
        
        html += `<g>
          <rect x="${PAD + p.x*scale}" y="${PAD + p.y*scale}" 
                width="${p.l*scale}" height="${p.w*scale}" 
                fill="#f3f4f6" stroke="#374151" stroke-width="2"/>`;
        
        // Part name
        if (availableW > 30 && availableH > 15) {
          html += `<text x="${PAD + p.x*scale + availableW/2}" 
                        y="${PAD + p.y*scale + availableH/2 - dimFont/2}" 
                        font-size="${nameFont}" font-weight="bold" 
                        fill="#1f2937" text-anchor="middle">${escapeHtml(p.comp["Name"])}</text>`;
        }
        
        // Dimensions
        if (availableW > 40 && availableH > 25) {
          html += `<text x="${PAD + p.x*scale + availableW/2}" 
                        y="${PAD + p.y*scale + availableH/2 + dimFont}" 
                        font-size="${dimFont}" fill="#374151" 
                        text-anchor="middle">${p.l} × ${p.w} mm</text>`;
        }
        
        html += `</g>`;
      });
      
      html += `</svg>`;
      
      // Parts list table
      html += `<div style="margin-top: 20px;">
        <h3 style="margin-bottom: 10px; color: #1f2937;">Parts List</h3>
        <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
          <thead>
            <tr style="background: #f3f4f6;">
              <th style="border: 1px solid #d1d5db; padding: 8px; text-align: left;">#</th>
              <th style="border: 1px solid #d1d5db; padding: 8px; text-align: left;">Name</th>
              <th style="border: 1px solid #d1d5db; padding: 8px; text-align: center;">Dimensions (mm)</th>
              <th style="border: 1px solid #d1d5db; padding: 8px; text-align: left;">Edging</th>
              <th style="border: 1px solid #d1d5db; padding: 8px; text-align: center;">Status</th>
            </tr>
          </thead>
          <tbody>`;
      
      parts.forEach((p, n) => {
        let comp = p.comp;
        let edging = [
          comp["Edging Length 1"],
          comp["Edging Length 2"],
          comp["Edging Width 1"],
          comp["Edging Width 2"]
        ].filter(e => e && e.trim()).join(', ') || 'None';
        
        html += `<tr>
          <td style="border: 1px solid #d1d5db; padding: 6px; text-align: center;">${n + 1}</td>
          <td style="border: 1px solid #d1d5db; padding: 6px;">${escapeHtml(comp["Name"])}</td>
          <td style="border: 1px solid #d1d5db; padding: 6px; text-align: center;">${p.l} × ${p.w}</td>
          <td style="border: 1px solid #d1d5db; padding: 6px;">${escapeHtml(edging)}</td>
          <td style="border: 1px solid #d1d5db; padding: 6px; text-align: center;">☐</td>
        </tr>`;
      });
      
      html += `</tbody></table></div></div>`;
      return html;
    }

    // Export to PDF function
    document.getElementById('exportPdfBtn').onclick = function() {
      // jsPDF UMD exposes window.jspdf.jsPDF
      if (!window.jspdf || !window.jspdf.jsPDF) {
        showNotification('PDF library not loaded', 'error');
        return;
      }
      
      showNotification('Generating PDF...', 'info');
      
      try {
  const { jsPDF } = window.jspdf;
        const doc = new jsPDF('landscape', 'mm', 'a4');
        
        let currentTabIndex = Array.from(document.querySelectorAll('.tab')).findIndex(t => t.classList.contains('selected'));
        if (currentTabIndex < 0) return;
        
        let key = currentBoards[currentTabIndex];
        let sheets = currentSheets[key];
        
        sheets.forEach((parts, pageIndex) => {
          if (pageIndex > 0) doc.addPage();
          
          // Title
          doc.setFontSize(20);
          doc.text(`Cutting Diagram - ${key}`, 20, 20);
          
          doc.setFontSize(12);
          doc.text(`Sheet ${pageIndex + 1} of ${sheets.length}`, 20, 30);
          doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 35);
          
          // Parts table
          let startY = 50;
          let rowHeight = 8;
          
          // Headers
          doc.setFontSize(10);
          doc.text('#', 20, startY);
          doc.text('Name', 30, startY);
          doc.text('Dimensions', 120, startY);
          doc.text('Edging', 160, startY);
          
          // Data rows
          parts.forEach((p, i) => {
            let y = startY + ((i + 1) * rowHeight);
            let comp = p.comp;
            let edging = [
              comp["Edging Length 1"],
              comp["Edging Length 2"], 
              comp["Edging Width 1"],
              comp["Edging Width 2"]
            ].filter(e => e && e.trim()).join(', ') || 'None';
            
            doc.text(`${i + 1}`, 20, y);
            doc.text(comp["Name"], 30, y);
            doc.text(`${p.l} × ${p.w} mm`, 120, y);
            doc.text(edging, 160, y);
          });
        });
        
        doc.save(`cutting-diagram-${key}-${new Date().toISOString().split('T')[0]}.pdf`);
        showNotification('PDF exported successfully!', 'success');
        
      } catch (error) {
        console.error('PDF export error:', error);
        showNotification('Error exporting PDF', 'error');
      }
    };

    // Settings Management
    function initializeSettings() {
      loadSettings();
      updatePrinterStatus();
      
      // Settings button
      document.getElementById('settingsBtn').onclick = function() {
        document.getElementById('settingsPopup').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
        updateSettingsUI();
      };
      
      // Close settings
      document.getElementById('settingsCloseBtn').onclick = closeSettings;
      document.getElementById('overlay').onclick = function(e) {
        if (e.target === this) closeSettings();
      };
      
      // Save settings handlers
      ['labelFontSize', 'labelBold', 'labelMargin', 'kerfWidth', 'minOffcutL', 'minOffcutW', 'grainPriority', 'nestingAlgorithm', 'printerType', 'labelSize'].forEach(setting => {
        let element = document.getElementById(setting);
        if (element) {
          element.addEventListener('change', function() {
            if (this.type === 'checkbox') {
              appSettings[setting] = this.checked;
            } else if (this.type === 'number') {
              appSettings[setting] = parseFloat(this.value) || 0;
            } else {
              appSettings[setting] = this.value;
            }
            saveSettings();
          });
        }
      });
      
      // PIN save handler
      document.getElementById('savePinBtn').onclick = function() {
        let pin = document.getElementById('pinInput').value.replace(/\D/g, "").substring(0, 4);
        if (pin.length === 4) {
          localStorage.setItem('cutPin', pin);
          document.getElementById('pinStatus').textContent = "PIN saved!";
          document.getElementById('pinStatus').style.color = "var(--success-color)";
        } else {
          document.getElementById('pinStatus').textContent = "Enter 4 digits";
          document.getElementById('pinStatus').style.color = "var(--danger-color)";
        }
        document.getElementById('pinInput').value = pin;
      };
      
      // Test print handler
      document.getElementById('testPrintSettingsBtn').onclick = testZebraPrint;
    }

    function closeSettings() {
      document.getElementById('settingsPopup').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
    }

    function updatePrinterStatus() {
      const statusDiv = document.getElementById('printerStatus');
      if (!statusDiv) return;
      
      discoverZebraPrinter(function(found) {
        if (found) {
          statusDiv.innerHTML = `<span style="color: var(--success-color);">✅ Zebra printer connected</span>`;
          statusDiv.className = 'success';
        } else {
          statusDiv.innerHTML = `<span style="color: var(--warning-color);">⚠️ Zebra printer not found. <a href="https://www.zebra.com/us/en/software/printer-software/browser-print.html" target="_blank">Download Browser Print</a></span>`;
          statusDiv.className = 'info';
        }
      });
    }

    // Project Management
    document.getElementById('saveProjectBtn').onclick = function() {
      document.getElementById('projectPopup').style.display = 'block';
      document.getElementById('overlay').style.display = 'block';
      loadSavedProjects();
    };

    document.getElementById('projectCloseBtn').onclick = function() {
      document.getElementById('projectPopup').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
    };

    document.getElementById('saveProjectConfirmBtn').onclick = function() {
      const name = document.getElementById('projectName').value.trim();
      if (!name) {
        showNotification('Please enter a project name', 'warning');
        return;
      }
      
      const projectData = {
        name: name,
        date: new Date().toISOString(),
        currentBoards: currentBoards,
        currentGroups: currentGroups,
        currentSheets: currentSheets,
        currentSheetPage: currentSheetPage,
        originalParts: originalParts,
        partPlacementMap: partPlacementMap,
        boardSizes: boardSizes,
        masterBoardDB: masterBoardDB,
        printedParts: printedParts,
        completedPages: completedPages,
        settings: appSettings
      };
      
      let savedProjects = JSON.parse(localStorage.getItem('savedProjects') || '{}');
      savedProjects[name] = projectData;
      localStorage.setItem('savedProjects', JSON.stringify(savedProjects));
      
      showNotification(`Project "${name}" saved successfully!`, 'success');
      document.getElementById('projectName').value = '';
      loadSavedProjects();
    };

    document.getElementById('loadProjectBtn').onclick = function() {
      const projectName = document.getElementById('savedProjects').value;
      if (!projectName) {
        showNotification('Please select a project to load', 'warning');
        return;
      }
      
      let savedProjects = JSON.parse(localStorage.getItem('savedProjects') || '{}');
      let project = savedProjects[projectName];
      
      if (project) {
        // Restore project data
        currentBoards = project.currentBoards || [];
        currentGroups = project.currentGroups || {};
        currentSheets = project.currentSheets || {};
        currentSheetPage = project.currentSheetPage || {};
        originalParts = project.originalParts || [];
        partPlacementMap = project.partPlacementMap || {};
        boardSizes = project.boardSizes || {};
        masterBoardDB = project.masterBoardDB || {};
        printedParts = project.printedParts || {};
        completedPages = project.completedPages || {};
        
        if (project.settings) {
          appSettings = { ...appSettings, ...project.settings };
          saveSettings();
          updateSettingsUI();
        }
        
        // Update UI
        updateTabsUI();
        updateHeaderButtons();
        
        if (currentBoards.length > 0) {
          window.selectTab(0);
        }
        
        showNotification(`Project "${projectName}" loaded successfully!`, 'success');
        document.getElementById('projectPopup').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
      } else {
        showNotification('Project not found', 'error');
      }
    };

    document.getElementById('deleteProjectBtn').onclick = function() {
      const projectName = document.getElementById('savedProjects').value;
      if (!projectName) {
        showNotification('Please select a project to delete', 'warning');
        return;
      }
      
      if (confirm(`Are you sure you want to delete project "${projectName}"?`)) {
        let savedProjects = JSON.parse(localStorage.getItem('savedProjects') || '{}');
        delete savedProjects[projectName];
        localStorage.setItem('savedProjects', JSON.stringify(savedProjects));
        
        showNotification(`Project "${projectName}" deleted`, 'info');
        loadSavedProjects();
      }
    };

    function loadSavedProjects() {
      const select = document.getElementById('savedProjects');
      const savedProjects = JSON.parse(localStorage.getItem('savedProjects') || '{}');
      
      select.innerHTML = '<option value="">Select a saved project...</option>';
      Object.keys(savedProjects).forEach(name => {
        const project = savedProjects[name];
        const date = new Date(project.date).toLocaleDateString();
        select.innerHTML += `<option value="${name}">${name} (${date})</option>`;
      });
    }

    // Help System
    document.getElementById('helpBtn').onclick = function() {
      document.getElementById('helpPopup').style.display = 'block';
      document.getElementById('overlay').style.display = 'block';
    };

    document.getElementById('helpCloseBtn').onclick = function() {
      document.getElementById('helpPopup').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
    };

    // Dark Mode Toggle
    document.getElementById('darkModeBtn').onclick = function() {
      const isDark = document.body.classList.toggle('darkmode');
      localStorage.setItem('darkMode', isDark.toString());
      
      this.textContent = isDark ? '☀️' : '🌙';
      showNotification(`${isDark ? 'Dark' : 'Light'} mode enabled`, 'info', 2000);
    };

    // Load dark mode preference
    if (localStorage.getItem('darkMode') === 'true') {
      document.body.classList.add('darkmode');
      document.getElementById('darkModeBtn').textContent = '☀️';
    }

    // Test Print Button
    document.getElementById('testPrintBtn').onclick = testZebraPrint;

    // Keyboard Shortcuts
    document.addEventListener('keydown', function(e) {
      // Don't trigger shortcuts if user is typing in an input
      if (e.target.tagName.toLowerCase() === 'input' || e.target.tagName.toLowerCase() === 'textarea') {
        return;
      }
      
      switch(e.key.toLowerCase()) {
        case 'p':
          if (e.ctrlKey) {
            e.preventDefault();
            window.printAllSheets();
          }
          break;
        case 's':
          if (e.ctrlKey) {
            e.preventDefault();
            document.getElementById('saveProjectBtn').click();
          }
          break;
        case 'e':
          if (e.ctrlKey) {
            e.preventDefault();
            document.getElementById('exportPdfBtn').click();
          }
          break;
        case ' ':
          e.preventDefault();
          if (e.shiftKey) {
            navigateSheet(-1); // Previous sheet
          } else {
            navigateSheet(1); // Next sheet
          }
          break;
        case '+':
        case '=':
          e.preventDefault();
          window.zoomSvg(1);
          break;
        case '-':
          e.preventDefault();
          window.zoomSvg(-1);
          break;
        case 'r':
          e.preventDefault();
          window.resetSvgPanZoom();
          break;
        case 'd':
          e.preventDefault();
          document.getElementById('darkModeBtn').click();
          break;
        case 'escape':
          window.hidePopup();
          closeSettings();
          break;
        case 'h':
          if (e.ctrlKey) {
            e.preventDefault();
            document.getElementById('helpBtn').click();
          }
          break;
        case '?':
          document.getElementById('helpBtn').click();
          break;
      }
    });

    function navigateSheet(direction) {
      let currentTabIndex = Array.from(document.querySelectorAll('.tab')).findIndex(t => t.classList.contains('selected'));
      if (currentTabIndex < 0) return;
      
      let key = currentBoards[currentTabIndex];
      let sheets = currentSheets[key] || [];
      let currentPage = currentSheetPage[key] || 0;
      let newPage = currentPage + direction;
      
      if (newPage >= 0 && newPage < sheets.length) {
        window.goToSheet(key, newPage);
        showNotification(`Sheet ${newPage + 1} of ${sheets.length}`, 'info', 1500);
      } else if (direction > 0 && currentTabIndex < currentBoards.length - 1) {
        // Move to next material, first sheet
        window.selectTab(currentTabIndex + 1);
        let nextKey = currentBoards[currentTabIndex + 1];
        window.goToSheet(nextKey, 0);
        showNotification(`Switched to ${nextKey} - Sheet 1`, 'info', 2000);
      } else if (direction < 0 && currentTabIndex > 0) {
        // Move to previous material, last sheet
        let prevKey = currentBoards[currentTabIndex - 1];
        let prevSheets = currentSheets[prevKey] || [];
        window.selectTab(currentTabIndex - 1);
        window.goToSheet(prevKey, prevSheets.length - 1);
        showNotification(`Switched to ${prevKey} - Sheet ${prevSheets.length}`, 'info', 2000);
      }
    }

    // Show shortcuts hint on hover
    let shortcutsTimeout;
    document.addEventListener('keydown', function(e) {
      if (e.ctrlKey || e.shiftKey || e.altKey) {
        clearTimeout(shortcutsTimeout);
        document.getElementById('shortcutsHelp').classList.add('show');
        
        shortcutsTimeout = setTimeout(() => {
          document.getElementById('shortcutsHelp').classList.remove('show');
        }, 3000);
      }
    });

    // Drag and Drop Support for CSV files
    function initializeDragDrop() {
      const dropZones = [
        document.getElementById('cuttingCsv').parentElement,
        document.getElementById('masterCsv').parentElement,
        document.body
      ];
      
      dropZones.forEach(zone => {
        zone.addEventListener('dragover', function(e) {
          e.preventDefault();
          if (zone !== document.body) {
            zone.classList.add('drag-over');
          }
        });
        
        zone.addEventListener('dragleave', function(e) {
          if (zone !== document.body) {
            zone.classList.remove('drag-over');
          }
        });
        
        zone.addEventListener('drop', function(e) {
          e.preventDefault();
          if (zone !== document.body) {
            zone.classList.remove('drag-over');
          }
          
          const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.csv'));
          if (files.length === 0) {
            showNotification('Please drop CSV files only', 'warning');
            return;
          }
          
          // Auto-assign files based on content or filename
          files.forEach(file => {
            if (file.name.toLowerCase().includes('master') || file.name.toLowerCase().includes('board')) {
              document.getElementById('masterCsv').files = createFileList([file]);
            } else {
              document.getElementById('cuttingCsv').files = createFileList([file]);
            }
          });
          
          showNotification(`${files.length} CSV file(s) loaded`, 'success');
        });
      });
    }

    function createFileList(files) {
      const dt = new DataTransfer();
      files.forEach(file => dt.items.add(file));
      return dt.files;
    }

    // Material Usage Analytics
    function generateAnalyticsReport() {
      if (!currentBoards.length) return null;
      
      let totalBoards = 0;
      let totalParts = 0;
      let totalWaste = 0;
      let totalUsed = 0;
      let materialBreakdown = {};
      
      currentBoards.forEach(boardKey => {
        const sheets = currentSheets[boardKey] || [];
        const size = boardSizes[boardKey];
        if (size && size.length && size.width) {
          const boardArea = size.length * size.width;
          totalBoards += sheets.length;

          let materialUsed = 0;
          let materialWaste = 0;
          let materialParts = 0;

          sheets.forEach(sheet => {
            let sheetUsed = 0;
            sheet.forEach(part => {
              sheetUsed += part.l * part.w;
              materialParts++;
            });
            materialUsed += sheetUsed;
            materialWaste += boardArea - sheetUsed;
          });

          totalParts += materialParts;
          totalUsed += materialUsed;
          totalWaste += materialWaste;

          materialBreakdown[boardKey] = {
            sheets: sheets.length,
            boardArea,
            totalUsed: materialUsed,
            utilization: sheets.length ? (materialUsed / (boardArea * sheets.length) * 100) : 0
          };
        }
      });
      
      return {
        totalBoards,
        totalParts,
        totalWaste: totalWaste / 1000000, // Convert to m²
        totalUsed: totalUsed / 1000000,   // Convert to m²
        overallUtilization: totalUsed / (totalUsed + totalWaste) * 100,
        materialBreakdown
      };
    }

    // Enhanced Error Handling
    window.addEventListener('error', function(e) {
      console.error('Application error:', e);
      showNotification('An unexpected error occurred. Check console for details.', 'error');
    });

    window.addEventListener('unhandledrejection', function(e) {
      console.error('Unhandled promise rejection:', e);
      showNotification('A processing error occurred. Please try again.', 'error');
    });

    // Initialize everything when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      loadSettings();
      initializeSettings();
      initializeDragDrop();
      updatePrinterStatus();
      
      // Auto-discover Zebra printer on load
      discoverZebraPrinter(function(found) {
        if (found) {
          console.log('Zebra printer automatically connected');
        } else {
          console.log('No Zebra printer found on startup');
        }
      });
      
      showNotification('Enhanced Cutting Diagram Tool loaded successfully!', 'success', 3000);
    });

    // Auto-save progress periodically
    setInterval(function() {
      if (currentBoards.length > 0) {
        const autoSaveData = {
          name: '__autosave__',
          date: new Date().toISOString(),
          currentBoards,
          currentGroups,
          currentSheets,
          currentSheetPage,
          originalParts,
          partPlacementMap,
          boardSizes,
          masterBoardDB,
          printedParts,
          completedPages,
          settings: appSettings
        };
        
        localStorage.setItem('autoSave', JSON.stringify(autoSaveData));
      }
    }, 30000); // Auto-save every 30 seconds

    // Load auto-saved data on startup if available
    window.addEventListener('load', function() {
      const autoSave = localStorage.getItem('autoSave');
      if (autoSave && currentBoards.length === 0) {
        try {
          const data = JSON.parse(autoSave);
          const autoSaveDate = new Date(data.date);
          const now = new Date();
          const hoursDiff = (now - autoSaveDate) / (1000 * 60 * 60);
          
          if (hoursDiff < 24) { // Only restore if less than 24 hours old
            if (confirm('Found auto-saved work from ' + autoSaveDate.toLocaleString() + '. Would you like to restore it?')) {
              // Restore the auto-saved state
              currentBoards = data.currentBoards || [];
              currentGroups = data.currentGroups || {};
              currentSheets = data.currentSheets || {};
              currentSheetPage = data.currentSheetPage || {};
              originalParts = data.originalParts || [];
              partPlacementMap = data.partPlacementMap || {};
              boardSizes = data.boardSizes || {};
              masterBoardDB = data.masterBoardDB || {};
              printedParts = data.printedParts || {};
              completedPages = data.completedPages || {};
              
              updateTabsUI();
              updateHeaderButtons();
              
              if (currentBoards.length > 0) {
                window.selectTab(0);
              }
              
              showNotification('Auto-saved work restored!', 'success');
            }
          }
        } catch (e) {
          console.error('Error loading auto-save:', e);
        }
      }
    });

    // Export functions to window for global access
    window.nestComponentsOnBoards = nestComponentsOnBoards;
    window.generateAnalyticsReport = generateAnalyticsReport;
    window.showNotification = showNotification;
    window.appSettings = appSettings;
    window.saveSettings = saveSettings;
    window.zebraPrinter = zebraPrinter;
    window.discoverZebraPrinter = discoverZebraPrinter;
    window.testZebraPrint = testZebraPrint;

    // Performance monitoring
    let performanceMetrics = {
      processingTime: 0,
      renderTime: 0,
      partsCount: 0,
      sheetsGenerated: 0
    };

    window.getPerformanceMetrics = function() {
      return performanceMetrics;
    };

  </script>
</body>
</html>